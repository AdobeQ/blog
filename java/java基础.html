<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>包 | 博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="记录日常学习内容，查漏补缺">
    
    <link rel="preload" href="/blog/assets/css/0.styles.59cd415b.css" as="style"><link rel="preload" href="/blog/assets/js/app.ed9cd75e.js" as="script"><link rel="preload" href="/blog/assets/js/3.24509252.js" as="script"><link rel="preload" href="/blog/assets/js/1.22e1a39c.js" as="script"><link rel="preload" href="/blog/assets/js/11.fdf41d93.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.94d783e0.js"><link rel="prefetch" href="/blog/assets/js/12.5ae033ab.js"><link rel="prefetch" href="/blog/assets/js/13.ccc38c90.js"><link rel="prefetch" href="/blog/assets/js/14.ea1776ae.js"><link rel="prefetch" href="/blog/assets/js/15.f8734838.js"><link rel="prefetch" href="/blog/assets/js/16.34f8c562.js"><link rel="prefetch" href="/blog/assets/js/4.6219b3e8.js"><link rel="prefetch" href="/blog/assets/js/5.0d7f0542.js"><link rel="prefetch" href="/blog/assets/js/6.8c461d9c.js"><link rel="prefetch" href="/blog/assets/js/7.7feb83a9.js"><link rel="prefetch" href="/blog/assets/js/8.20e0fc1f.js"><link rel="prefetch" href="/blog/assets/js/9.01e0ebc0.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.59cd415b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-5bb33761><div data-v-5bb33761><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-5bb33761 data-v-5bb33761><h3 class="title" data-v-59e6cb88>博客</h3> <p class="description" data-v-59e6cb88>记录日常学习内容，查漏补缺</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2022
      </a></span></div></div> <div class="hide" data-v-5bb33761><header class="navbar" data-v-5bb33761><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      知识库
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  FAQ
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  HowTo
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      了解更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  AWTK 官网
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  AWTK 云平台
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  GitHub 仓库
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  Gitee 仓库
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-5bb33761></div> <aside class="sidebar" data-v-5bb33761><div class="personal-info-wrapper" data-v-1fad0c41 data-v-5bb33761><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>5</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      知识库
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  FAQ
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  HowTo
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      了解更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  AWTK 官网
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  AWTK 云平台
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  GitHub 仓库
</a></li><li class="dropdown-item"><!----> <a href="/blog/java/.html" class="nav-link"><i class="undefined"></i>
  Gitee 仓库
</a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active open"><span>javaSE</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/java基础.html" class="active sidebar-link">java基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>spring</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/spring注解.html" class="sidebar-link">spring</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-5bb33761><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2022
      </a></span></div></div> <div data-v-5bb33761><div data-v-5bb33761><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">包</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="包"><a href="#包" class="header-anchor">#</a> 包</h1> <p>命名规则：
只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</p> <p>命名规范：
com.公司名.项目名.业务模块名</p> <h2 id="常用的包"><a href="#常用的包" class="header-anchor">#</a> 常用的包</h2> <p>java.lang.* //lang是常用包，默认引入，不需要引入
java utils //util包，系统提供的工具包，工具类
java。net	//网络包，网络开发
java。awt //java界面开发</p> <h2 id="包的使用细节"><a href="#包的使用细节" class="header-anchor">#</a> 包的使用细节</h2> <h1 id="面向对象编程-继承-重点掌握"><a href="#面向对象编程-继承-重点掌握" class="header-anchor">#</a> 面向对象编程-继承（重点掌握）</h1> <p>1、子类继承所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和
方法不能在子类直接访问，要通过父类提供公共的方法去访问
4、如果希望指定去调用父类的某个构造器，则显示的调用一下：spuer（参数列表）
5、super在使用时，必须放在构造器第一行（spuer只能在构造器中使用）
6、super（）和this（）都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
9、子类最多只能继承一个父类（指直接继承），即java中是单继承机制
10、不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p> <h1 id="super关键字"><a href="#super关键字" class="header-anchor">#</a> super关键字</h1> <table><thead><tr><th>No.</th> <th>区别点</th> <th>this</th> <th>super</th></tr></thead> <tbody><tr><td>1</td> <td>访问属性</td> <td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td> <td>从父类开始查找属性</td></tr> <tr><td>2</td> <td>调用方法</td> <td>访问本类中的方法，如果本类没有此方法则从父类继续查找</td> <td>从父类开始查找</td></tr> <tr><td>3</td> <td>调用构造器</td> <td>调用本类构造器，必须放在构造器的首行</td> <td>调用父类构造器，必须放在子类构造器的首行</td></tr> <tr><td>4</td> <td>特殊</td> <td>表示当前对象</td> <td>子类中访问父类对象</td></tr></tbody></table> <h1 id="方法重写-override"><a href="#方法重写-override" class="header-anchor">#</a> 方法重写(override)</h1> <h2 id="注意事项和使用细节"><a href="#注意事项和使用细节" class="header-anchor">#</a> 注意事项和使用细节</h2> <p>方法重写也叫方法覆盖，需要满足下面条件</p> <p>1、子类的方法的形参列表、方法名臣，要和父类方法的形参列表，方法名称完全一样
2、子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类
比如 父类返回类型是Object，子类方法返回类型是String
3、子类方法不能缩小父类方法的访问权限。（public -&gt; protected -&gt; 默认 -&gt; private</p> <h2 id="方法重写和重载比较"><a href="#方法重写和重载比较" class="header-anchor">#</a> 方法重写和重载比较</h2> <table><thead><tr><th>名称</th> <th>发生范围</th> <th>方法名</th> <th>形参列表</th> <th>返回类型</th> <th>修饰符</th></tr></thead> <tbody><tr><td>重载（overload）</td> <td>本类</td> <td>必须一样</td> <td>类型、个数或者顺序至少有一个不同</td> <td>无需求</td> <td>无需求</td></tr> <tr><td>重写（override）</td> <td>父子类</td> <td>必须一样</td> <td>相同</td> <td>子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类</td> <td>子类方法不能缩小父类方法的访问范围</td></tr></tbody></table> <h1 id="面向对象编程-多态"><a href="#面向对象编程-多态" class="header-anchor">#</a> 面向对象编程-多态</h1> <h2 id="多态注意事项和细节讨论"><a href="#多态注意事项和细节讨论" class="header-anchor">#</a> 多态注意事项和细节讨论</h2> <ul><li>多态的前提是：两个对象（类）存在继承关系</li> <li>多态的向上转型</li></ul> <ol><li>本质：父类的引用指向了子类的对象</li> <li>语法：父类类型 引用名 = new 子类类型();</li> <li>特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员
（需遵守访问权限），不能调用子类中特有成员；最终运行效果看子类的具体实现（即调用
方法时，按照子类（运行类型）开始查找方法，然后调用）</li></ol> <h2 id="多态的向下转型"><a href="#多态的向下转型" class="header-anchor">#</a> 多态的向下转型</h2> <ol><li>语法：子类类型 引用名 = （子类类型）父类引用；</li> <li>只能强转父类的引用，不能强转父类的对象</li> <li>要求父类的引用必须指向的是当前目标类型的对象</li> <li>可以调用子类类型中所有的成员（属性和方法）</li></ol> <p>属性没有重写之说，属性的值看编译类型。
instanceOf比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的
子类型。</p> <h2 id="java的动态绑定机制-非常非常重要"><a href="#java的动态绑定机制-非常非常重要" class="header-anchor">#</a> java的动态绑定机制（非常非常重要）</h2> <p>java重要特性：动态绑定机制
java的动态绑定机制</p> <ol><li>当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定</li> <li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol> <h2 id="多态应用"><a href="#多态应用" class="header-anchor">#</a> 多态应用</h2> <ol><li>多态数组。数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</li> <li>多态参数。方法定义的形参类型为父类类型，实参类型允许为子类类型</li></ol> <h1 id="object类详解"><a href="#object类详解" class="header-anchor">#</a> Object类详解</h1> <h2 id="和-equals的对比"><a href="#和-equals的对比" class="header-anchor">#</a> == 和 equals的对比</h2> <p>== 是一个比较运算符</p> <ol><li>==：既可以判断基本类型，又可以判断引用类型</li> <li>==：如果判断基本类型，判断的是值是否相等。示例：int i = 10;double d = 10.0;</li> <li>==: 如果判断引用类型，判断的是地址是否相等，及判断是不是同一个对象</li> <li>equals：是Object类中的方法，只能判断引用类型</li> <li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如：Integer，String</li></ol> <h2 id="hashcode方法"><a href="#hashcode方法" class="header-anchor">#</a> hashCode方法</h2> <ol><li>提高具有哈希结构的容器的效率；</li> <li>两个引用，如果指向的是同一个对象，则哈希值是一样的</li> <li>两个引用，如果指向的是不同对象，则哈希值是不一样的
4.哈希值主要根据地址号来，不能完全将哈希值等价于地址</li></ol> <h2 id="tostring"><a href="#tostring" class="header-anchor">#</a> toString</h2> <p>基本介绍：
默认返回：全类名（包名+类名）+@+哈希值的十六进制
重写toString方法，打印对象或拼接对象时都会自动调用对象的toString形式
当直接输出一个对象时，toString方法会被默认的调用</p> <h2 id="finalize方法-开发中使用较少"><a href="#finalize方法-开发中使用较少" class="header-anchor">#</a> finalize方法（开发中使用较少）</h2> <ol><li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法。
做一些资源释放操作</li> <li>什么时候回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾
对象，就会使用垃圾回收机制来销毁该对象，在销毁对象前，会先调用finalize方法</li> <li>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()
主动除法垃圾回收机制</li></ol> <h1 id="面向对象高级"><a href="#面向对象高级" class="header-anchor">#</a> 面向对象高级</h1> <h2 id="类变量和类方法"><a href="#类变量和类方法" class="header-anchor">#</a> 类变量和类方法</h2> <h3 id="什么是类变量"><a href="#什么是类变量" class="header-anchor">#</a> 什么是类变量</h3> <p>类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类
的对象去访问（修改）它时，取到（修改）的都是相同的值。</p> <h3 id="如何定义类变量"><a href="#如何定义类变量" class="header-anchor">#</a> 如何定义类变量</h3> <p>定义语法： 访问修饰符 static 数据类型 变量名；【推荐】</p> <h3 id="类变量的内存布局-跟jdk版本有关"><a href="#类变量的内存布局-跟jdk版本有关" class="header-anchor">#</a> 类变量的内存布局（跟jdk版本有关）</h3> <ol><li>static变量是同一个类所有对象共享</li> <li>static类变量，在加载的时候就生成</li></ol> <h3 id="类变量的使用注意事项和细节"><a href="#类变量的使用注意事项和细节" class="header-anchor">#</a> 类变量的使用注意事项和细节</h3> <ol><li>什么时候需要类变量
当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用
类变量（静态变量）</li> <li>类变量与实例变量（普通属性）区别
类变量是该类的所有对象共享的，而实例变量的每个对象独享的</li> <li>加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态方法</li> <li>类变量可以通过 类名.类变量名（推荐） 或者 对象名.类变量名来访问</li></ol> <h3 id="类方法基本介绍"><a href="#类方法基本介绍" class="header-anchor">#</a> 类方法基本介绍</h3> <p>类方法也叫静态方法</p> <h3 id="如何定义类变量-2"><a href="#如何定义类变量-2" class="header-anchor">#</a> 如何定义类变量</h3> <p>定义语法： 访问修饰符 static 数据返回类型 方法名(){}【推荐】
类方法可以通过 类名.类方法名（推荐） 或者 对象名.类方法名来访问</p> <h3 id="类方法使用注意事项和细节"><a href="#类方法使用注意事项和细节" class="header-anchor">#</a> 类方法使用注意事项和细节</h3> <ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区
类方法中无this的参数</li> <li>类方法可以通过类名调用，也可以通过对象名调用</li> <li>普通方法的对象有关，需要通过对象名调用</li> <li>类方法中不与允许使用和对象有关的关键字，比如this和super</li> <li>类方法（静态方法）中只能访问静态变量或静态方法</li> <li>普通成员方法，即可访问普通方法（变量），也可以访问静态变量（方法）</li></ol> <h2 id="main方法"><a href="#main方法" class="header-anchor">#</a> main方法</h2> <h2 id="代码块"><a href="#代码块" class="header-anchor">#</a> 代码块</h2> <p>基本介绍
代码块又称为初始化块，属于类中的成员【既是类的一部分】，类似于方法，将逻辑语句
封装在方法体中，通过{}包围起来。
但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或
类显示调用，而是加载类时，或创建对象时隐式调用</p> <p>基本语法
【修饰符】{
代码
};
注意：</p> <ol><li>修饰符可选，要写的话只能写static</li> <li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块</li> <li>逻辑语句可以为任何逻辑语句
4。 ;号可以写上也可以省略</li></ol> <p>代码块使用注意事项和细节</p> <ol><li>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行
一次，如果是普通代码块，每创建一个对象，就执行</li> <li>类什么时候被加载（重要）
<ul><li>创建对象实例时。（new）</li> <li>创建子类对象实例，父类也会被加载</li> <li>使用类的静态成员时（静态属性，静态方法）</li></ul></li> <li>普通代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。
如果只是使用类的静态成员，普通的代码块并不会执行。</li> <li>创建一个对象时，在一个类调用顺序是：（重点，难点）：
<ul><li>调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化
调用优先级一样，如果多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</li> <li>调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化
调用优先级一样，如果多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）
*调用构造方法。</li></ul></li> <li>构造器的最前面其实是隐含了super（）和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，
就执行完毕，因此优先于构造器和普通代码块执行。</li> <li>创建一个子类对象时（继承关系），静态代码块，静态属性初始化，普通代码块，
普通属性初始化，构造方法的调用顺序如下：
<ul><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</li> <li>子类的静态代码块的静态属性（优先级一样，按定义顺序执行）</li> <li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li> <li>父类的构造方法</li> <li>子类的构普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li> <li>子类的构造方法 //面试题</li></ul></li> <li>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。</li></ol> <h2 id="单例模式"><a href="#单例模式" class="header-anchor">#</a> 单例模式</h2> <p>实现步骤：</p> <ol><li>构造器私有化</li> <li>类的内部创建对象</li> <li>向外暴露一个静态公共方法</li></ol> <p>饿汉模式vs懒汉模式</p> <ol><li>二者最主要的区别在于创建对象的时机不同；饿汉式是在类加载就创建了对象实例
而懒汉式是在使用时才创建</li> <li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li> <li>饿汉式存在资源浪费的可能。
4.在javaSE标准类中，java.lang.Runtime就是经典的单例模式</li></ol> <h2 id="final关键字"><a href="#final关键字" class="header-anchor">#</a> final关键字</h2> <p>基本介绍
final可以修饰类、属性、方法和局部变量
final使用场景：</p> <ol><li>当不希望类被继承时，可以用final修饰</li> <li>当不希望父类的某个方法被子类覆盖/重写时。可以用final关键字修饰</li> <li>当不希望类的某个属性的值被修改，可以用final修饰</li> <li>当不希望某个局部变量被修改，可以使用final修饰</li></ol> <p>final使用注意事项和细节</p> <ol><li>final修饰的属性又叫常量，一般用XX_XX_XX来命名</li> <li>final修饰的属性在定义时，必须赋初始值，并且以后不能再修改，赋值可以在
如下位置之一
<ul><li>定义时</li> <li>再构造器中</li> <li>再代码块中</li></ul></li> <li>如果final修饰的属性是静态的，则初始化的位置只能是
<ul><li>定义时</li> <li>再静态代码块 不能再构造器中赋值</li></ul></li> <li>final类不能继承，但是可以实例化对象</li> <li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。</li> <li>如果一个类已经是final类了，就没有必要再将方法修饰成final方法</li> <li>final不能修饰构造方法</li> <li>final和static搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</li> <li>包装类（Integer，Double，Float，Boolean等都是final），String也是final类</li></ol> <h2 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h2> <p>抽象类的介绍</p> <ol><li>用abstract关键字来修饰一个类时，这个类就叫抽象类 访问修饰符 abstract 类名{}</li> <li>用abstract关键字来修饰一个方法时，这个方法就是抽象方法
访问修饰符 abstract 返回类型 方法名 (参数列表);//没有方法体</li> <li>抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类（）</li> <li>抽象类，在框架和设计模式使用较多</li></ol> <p>抽象类使用的注意事项和细节</p> <ol><li>抽象类不能被实例化</li> <li>抽象类不一定包含abstract方法</li> <li>一旦类包含了abstract方法，则这个类必须声明为abstract</li> <li>abstract只能修饰类的方法，不能修饰属性和其他的
5.抽象类可以又任意成员[抽象类本质还是类]</li> <li>抽象方法不能有主体，既不能实现</li> <li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也
声明为abstract类</li> <li>抽象方法不能使用private、final和static来修饰，因为这些关键字都i是和重写相违背</li></ol> <p>抽象类最佳实践-模板设计模式
abstract class Template{//抽象类
public abstract void job();//抽象方法
public void caleTimes(){//统计耗时多久
//统计当前时间距离 1970-1-1 0:0:0 的时间差，单位ms
long start = System.currentTimeMillis();
job();//java动态绑定机制
long end = System.currentTimeMillis();
System.out.println(&quot;耗时：&quot; + (end - start));
}</p> <p>}</p> <h2 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h2> <p>基本介绍
接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据集体情况
把这个方法实现
语法：
interface 接口名{
//属性
//方法(1.抽象方法 2.默认实现方法(default) 3.静态方法)
}</p> <p>class 类名 implements 接口{
自己属性；
自己方法：
必须实现的接口的抽象方法
}</p> <p>接口的注意事项和使用细节</p> <ol><li>接口不能被实例化</li> <li>接口中所有方法是public方法，接口中抽象方法，可以不用abstract修饰</li> <li>一个普通类实现接口，就必须将该接口的所有方法都实现</li> <li>抽象类实现接口，可以不用实现接口的方法</li> <li>一个类同时可以实现多个接口</li> <li>接口中的属性只能是final的，而且是public static final修饰符</li> <li>接口中属性的访问形式：接口名.属性名</li> <li>一个接口不能继承其他的类，但是可以继承多个别的接口</li> <li>接口的修饰符只能是public和默认</li></ol> <p>实现接口vs继承类</p> <ul><li>接口和继承解决的问题不同
继承的价值主要在于：解决代码的复用性和可维护性
接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法</li> <li>接口比继承更加灵活
接口比继承更加灵活，继承是满足is-a的关系，而接口只需要满足like-a的关系</li> <li>接口在一个程度上实现代码解耦</li></ul> <p>接口的多态特性</p> <ol><li>多态参数</li> <li>多态数组</li> <li>接口存在多态传递现象</li></ol> <h1 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h1> <h2 id="局部内部类的使用"><a href="#局部内部类的使用" class="header-anchor">#</a> 局部内部类的使用</h2> <p>说明：局部内部类定义在外部类的局部位置，比如方法中，并且有类名</p> <ol><li>可以直接访问外部类的所有成员，包含私有的</li> <li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量不能使用
修饰符。但是可以使用final修饰</li> <li>作用域：仅仅在定义它的方法或代码块中</li> <li>局部内部类--访问---&gt;外部类的成员【访问方式：直接访问】</li> <li>外部类--访问---&gt; 局部内部类的成员【访问方式：创建对象访问，必须在作用域内】</li> <li>外部其他类--不能访问---&gt; 局部内部类（因为局部内部类是一个局部变量）</li> <li>如果外部类和局部内部类的成员重名，默认遵循就近原则，如果想访问外部类的
成员，则可以使用（外部类名.this.成员）去访问</li></ol> <h2 id="匿名内部类-重点"><a href="#匿名内部类-重点" class="header-anchor">#</a> 匿名内部类（重点）</h2> <p>说明：匿名内部类是定义在外部类的局部位置
匿名内部类的使用
1.匿名内部类的基本语法
new 类或接口(参数列表){
类体
};
2. 匿名内部类既是一个类的定义、同时本身也是一个对象
3. 可以直接访问外部类的所有成员，包含私有的
4. 不能添加任意访问修饰符，因为它的地位就是一个局部变量
5. 仅仅在定义它的方法或代码块中
6. 匿名内部类--访问---&gt;外部类的成员【访问方式：直接访问】
7. 外部其他类--不能访问---&gt; 匿名内部类（因为它的地位就是一个局部变量）
8. 如果外部类和内部类的成员重名，默认遵循就近原则，如果想访问外部类的
成员，则可以使用（外部类名.成员）去访问</p> <h2 id="成员内部类"><a href="#成员内部类" class="header-anchor">#</a> 成员内部类</h2> <p>成员内部类的使用
说明：成员内部类是定义在外部类的成员位置，并且没有static修饰</p> <ol><li>可以直接访问外部类的所有成员，包含私有的</li> <li>可以添加任意访问修饰符（public、protected、默认、private）</li> <li>作用域：和外部类的其他成员一样，为整个类体</li> <li>成员内部类--访问---&gt;外部类的成员【访问方式：直接访问】</li> <li>外部类--访问---&gt; 内部类【访问方式：创建对象访问】</li> <li>外部其他类--访问---&gt; 成员内部类</li> <li>如果外部类和内部类的成员重名，默认遵循就近原则，如果想访问外部类的
成员，则可以使用（外部类名.this.成员）去访问</li></ol> <h2 id="静态内部类"><a href="#静态内部类" class="header-anchor">#</a> 静态内部类</h2> <p>静态内部类的使用
说明：静态内部类是定义在外部类的成员位置，并且有static修饰</p> <ol><li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li> <li>可以添加任意访问修饰符（public、protected、默认、private）</li> <li>作用域：和其他成员一样，为整个类体</li> <li>静态内部类--访问---&gt;外部类【访问方式：直接访问】</li> <li>外部类--访问---&gt; 静态内部类【访问方式：创建对象访问】</li> <li>外部其他类--访问---&gt; 静态内部类（通过类名直接访问或编写一个方法，返回静态内部类的对象实例）</li> <li>如果外部类和静态内部类的成员重名，默认遵循就近原则，如果想访问外部类的
成员，则可以使用（外部类名.成员）去访问</li></ol> <h1 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="header-anchor">#</a> 自定义类实现枚举</h1> <ol><li>构造器私有话</li> <li>本类内部创建一组对象</li> <li>对外暴露对象（通过为对象添加public final static修饰符）</li> <li>可以提供get方法，但是不要提供set</li></ol> <h1 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h1> <h2 id="try-catch"><a href="#try-catch" class="header-anchor">#</a> try-catch</h2> <p>try-catch-finally执行顺序小结</p> <ol><li>如果没有出现异常。则执行try块中所有语句，不执行catch块中语句，如果
有finally，最后还需要执行finally里面的语句</li> <li>如果出现异常，则try块中异常发生后，try块剩下的语句不再执行，将执行
catch块中的语句，如果finally，最后还需要执行finally里面的语句</li></ol> <h2 id="throw异常处理"><a href="#throw异常处理" class="header-anchor">#</a> throw异常处理</h2> <p>注意事项和使用细节</p> <ol><li>对于编译异常，程序中必须处理</li> <li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li> <li>子类重写父类时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和
父类抛出的异常一致，要么为父类抛出的异常类型的子类型</li> <li>再throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</li></ol> <h1 id="包装类"><a href="#包装类" class="header-anchor">#</a> 包装类</h1> <p>##包装类的分类</p> <ol><li>针对八种基本数据类型相应的引用类型--包装类
2.有了类的特点，就可以调用类中的方法</li></ol> <table><thead><tr><th>基本数据类型</th> <th>包装类</th></tr></thead> <tbody><tr><td>boolean</td> <td>Boolean</td></tr> <tr><td>char</td> <td>Character</td></tr> <tr><td>byte</td> <td>Byte</td></tr> <tr><td>short</td> <td>Short</td></tr> <tr><td>int</td> <td>Integer</td></tr> <tr><td>long</td> <td>Long</td></tr> <tr><td>float</td> <td>Float</td></tr> <tr><td>double</td> <td>Double</td></tr></tbody></table> <p>包装类和基本数据的转换</p> <ol><li>jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型，反之，拆箱</li> <li>jdk5以后(含jdk5)的自动装箱和拆箱方式</li> <li>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()
自动拆箱底层调用的是intValue方法。</li></ol> <blockquote><p>包装类测试题目</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Object obj1 = true?new Integer(1):new Double(2.0);//三元运算符是一个整体
System.out.println(obj1);//输出1.0
</code></pre></div><p>包装类型和String类型的相互转换</p> <blockquote><p>包装类型——&gt;String类型</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Integer i =10;
//方式1：
String s1 = i.toString();
//方式2：
String s2 = String.alueOf(i);
//方式3：
String s3 = i + &quot;&quot;;
</code></pre></div><blockquote><p>String -&gt; 包装类</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//方式1：
Integer j =new Integer(s1);
//方式2：
Integer j2 = Integer.valueOf(s2)
</code></pre></div><blockquote><p>Inreger类题目</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//示例1
Integer i1 = new Integer(127);
Integer i2 = new Integer(127);
System.out.println(i1 == i2);//F
//示例2
Integer i3 = new Integer(128);
Integer i4 = new Integer(128);
System.out.println(i3 == i4);//F
//示例3
Integer i5 = 127;
Integer i6 = 127;
System.out.println(i5 == i6);//T
//示例4
Integer i7 = 128;
Integer i8 = 128;
System.out.println(i1 == i2);//F
//示例5
Integer i9 = 127;
Integer i10 = new Integer(127);
System.out.println(i9 == i10);//F
//示例6
Integer i11 = 127;
int i12 = 127;
//只要有基本数据类型，判断的是值是否相等
System.out.println(i11 == i2);//T
//示例7
Integer i13 = 128;
int i14 = 128;
System.out.println(i13 == i4);//T

</code></pre></div><h2 id="string类"><a href="#string类" class="header-anchor">#</a> String类</h2> <p>字符串特性</p> <div class="language- extra-class"><pre class="language-text"><code>String a = &quot;hello&quot;;;
String b = &quot;abc&quot;;
String c = a+b;//创建了几个对象？内存图
</code></pre></div><p>底层是StringBuilder sb = new StringBuilder();
sb.append(a);sb.append(b);sb是在堆中，并且append是在原来的字符串的基础上追加
重要规则：String c = &quot;ab&quot; + &quot;cd&quot;;常量相加，看的是池。
String c = a + b;变量相加，是在堆中</p> <blockquote><p>String常用方法</p></blockquote> <p>toUpperCase()
concat()
replace()
split()
toCharArray()
compareTo()</p> <p>StringBuffer类</p> <blockquote><p>StringBuffer类常见方法</p></blockquote> <ol><li>增 append</li> <li>删 delete</li> <li>改 replace（start，end，string）//将start---end间的内容替换掉，不含end</li> <li>查indexOf // 查找子串在字符串第一次出现的索引，如果找不到返回-1</li> <li>插 insert</li> <li>获取长度length</li></ol> <blockquote><p>StringBuilder类基本介绍</p></blockquote> <ol><li>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步。该类
被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。
如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快</li> <li>在StringBuilder上的主要操作是append和insert方法，可重载这些方法仪接收
任意类型的数据</li></ol> <blockquote><p>String、StringBuffer 和 StringBuilder的选择</p></blockquote> <p>使用的原则，结论：</p> <ol><li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li> <li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li> <li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li> <li>如果字符串很少修改，被多个对象引用，使用String，比如配置信息</li></ol> <h2 id="math类"><a href="#math类" class="header-anchor">#</a> Math类</h2> <blockquote><p>Math类常见方法</p></blockquote> <ol><li>abs 绝对值</li> <li>pow 求幂</li> <li>ceil 向上取整</li> <li>floor 向下取整</li> <li>round 四舍五入</li> <li>sqrt 求开方</li> <li>random 求随机数</li> <li>max 求两个数的最大值</li> <li>min 求两个数的最小值</li></ol> <h2 id="arrays类"><a href="#arrays类" class="header-anchor">#</a> Arrays类</h2> <blockquote><p>Arrays里面包含了一系列静态方法，用于管理或操作数组</p></blockquote> <ol><li>toString返回数组的字符串形式</li> <li>sort排序(自然排序和定制排序)</li> <li>binarySearch通过二分搜索法进行查找，要求必须排好序</li></ol> <h2 id="system类"><a href="#system类" class="header-anchor">#</a> System类</h2> <blockquote><p>System类常见方法和案例</p></blockquote> <ol><li>exit退出当前程序</li> <li>arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</li> <li>currentTimeMillens:返回当前时间距离1970-1-1的毫秒数</li> <li>gc:运行垃圾回收机制 System.gc();</li></ol> <h2 id="大数据处理"><a href="#大数据处理" class="header-anchor">#</a> 大数据处理</h2> <p>BigInteger和BigDecimal</p> <blockquote><p>常用方法
1.add家
2.subtract减
3.multiply乘
4.divide除(除法需要通过BigDecimal.ROUND_CEILING指定精度)
应用场景：</p></blockquote> <ol><li>BigInteger适合保存比较大的整型</li> <li>BigDecimal适合保存精度更高的浮点型（小数）</li></ol> <h2 id="日期类-了解即可"><a href="#日期类-了解即可" class="header-anchor">#</a> 日期类（了解即可）</h2> <blockquote><p>第一代日期类</p></blockquote> <ol><li>Date:精确到毫秒，代表特定的瞬间</li> <li>SimpleDateFormat：格式和解析日期的类
SimpleDateFormat格式化和解析日期的具体类。它允许进行
格式化（日期-&gt;文本）、解析（文本-&gt;日期）和规范化</li></ol> <blockquote><p>第二代日期类</p></blockquote> <ol><li>第二代日期类，主要是Calender类(日历)</li> <li>Calender类是一个抽象类，它为特定瞬间与诸如Year、MONTH等日历字段
提供一些方法，并为操作日历字段提供一些方法</li></ol> <blockquote><p>第三代日期类</p></blockquote> <p>前面两代日期类的不足分析
JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入
Calendar类之后被弃用了，而Calendar也存在问题是
*可变性：像日期和时间这样的类应该是不可变的</p> <ul><li>偏移性：Date中的年份是从1990开始的，而月份都从0开始</li> <li>格式化：格式化只对Date有用，Calendar则不行</li> <li>此外，它们也不是线程安全的；不能处理闰秒等（每隔两天，多出1秒）</li></ul> <ol><li>LocalDate(日期/年月日)、LocalTime（时间/时分秒）、LocalDateTime（日期时间/年月日时分秒）JDK8加入</li> <li>DateTimeFormatter格式化日期类<div class="language- extra-class"><pre class="language-text"><code>DateTimeFormat dtf = DateTimeFormatter.ofPattern(格式)
String str = dtf.format(日期对象);
</code></pre></div></li> <li>Instant 时间戳
类似于Date
提供了一系列和Date类转换的方式
<blockquote><p>Instant --&gt; Date</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Date date = Date.from(instant);
</code></pre></div><blockquote><p>Date --&gt; Instant
Instant instant = date.toInstant();</p></blockquote></li> <li>第三代日期类更多方法</li></ol> <ul><li>LocalDateTime类</li> <li>MonthDay类：检查重复事件</li> <li>是否是闰年</li> <li>增加日期的某个部分</li> <li>使用plus方法测试增加时间的某个部分</li> <li>使用minus方法测试查看一年前和一年后的日期</li></ul> <h2 id="set接口实现类-hashset"><a href="#set接口实现类-hashset" class="header-anchor">#</a> Set接口实现类-HashSet</h2> <p>HashSet底层机制说明</p> <ol><li>Hash底层是HsahMap</li> <li>添加一个元素时，先得到hash值-会转成索引</li> <li>找到存储数据表table，看这个索引位置是否已经存放元素</li> <li>如果没有直接加入</li> <li>如果有，调用equals比较，如果相同，就放弃添加，如果不同，则添加到最后</li> <li>再java</li></ol> <h1 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h1> <p>集合的框架体系图</p> <h2 id="collection接口和常用方法"><a href="#collection接口和常用方法" class="header-anchor">#</a> Collection接口和常用方法</h2> <ul><li>Collection接口遍历元素方式1-使用Iterator（迭代器）</li></ul> <ol><li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</li> <li>所有实现了Collection接口的集合类都有一个Iterator()方法，用以返回
一个实现了Iterator接口的对象，即可返回一个迭代器</li> <li>Iterator的结构</li> <li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li></ol> <blockquote><p>迭代器的执行原理</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Iterator iterator = coll.iterator();//得到一个集合的迭代器
while (iterator.hasNext()) {//判断是否还有下一个元素
     Object next = iterator.next(); //next()作用和：1.下移 2.将下移以后集合位置上的元素返回          
}
</code></pre></div><ul><li>Collection接口遍历元素方式2-for循环增强
增强for循环，可以替代iterator迭代器，特点：增强for就是简化版的iterator，
本质是一样。只能用于遍历集合或数组</li></ul> <blockquote><p>基本语法</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>for(元素类型 元素名 ： 集合名或数组名){
    访问元素
}
</code></pre></div><h2 id="list接口"><a href="#list接口" class="header-anchor">#</a> List接口</h2> <h2 id="arraylist底层结构和源码分析-重点-难点"><a href="#arraylist底层结构和源码分析-重点-难点" class="header-anchor">#</a> ArrayList底层结构和源码分析（重点，难点）</h2> <ol><li>ArrayList中维护了一个Object类型的数组elementData。
transient Object[] elementData；//transient 表示瞬间，短暂的，表示该属性不会被序列化</li> <li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容
elementData为10，如需要再次扩容，则扩容elementData为1.5倍</li> <li>如果使用的是指定大小的构造器，则初始化elementData容量为指定大小，如果需要扩容，则直接扩容
elementData为1.5倍。</li></ol> <h2 id="vector底层结构和源码分析"><a href="#vector底层结构和源码分析" class="header-anchor">#</a> Vector底层结构和源码分析</h2> <ol><li>Vector类的定义说明</li> <li>Vector底层也是一个对象数组，protected Object[] elementData;</li> <li>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</li> <li>在开发中，需要线程同步安全时，考虑使用Vector</li></ol> <blockquote><p>Vector和ArrayList的比较</p></blockquote> <table><thead><tr><th></th> <th>底层结构</th> <th>版本</th> <th>线程安通（同步）效率</th> <th>扩容倍速</th></tr></thead> <tbody><tr><td>ArrayList</td> <td>可变数组</td> <td>jdk1.2</td> <td>不安全，效率高</td> <td>如果有参构造1.5倍 如果是无参 1.第一次10 2.从第二次开始1.5倍扩容</td></tr> <tr><td>Vector</td> <td>可变数组 Object[]</td> <td>jdk1.0</td> <td>安全，效率不高</td> <td>如果是无参，默认10，满后就2倍扩容 如果指定大小，则每次直接按照2倍扩容</td></tr></tbody></table> <h2 id="linkedlist的底层结构"><a href="#linkedlist的底层结构" class="header-anchor">#</a> LinkedList的底层结构</h2> <ol><li>LinkedList底层维护了一个双向链表</li> <li>LinkedList中维护了两个属性first和last分别指向首节点和尾节点</li> <li>每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过
prev指向前一个，通过next指向后一个节点，最终实现双向链表</li> <li>所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高</li></ol> <h2 id="arraylist和linkedlist的比较"><a href="#arraylist和linkedlist的比较" class="header-anchor">#</a> ArrayList和LinkedList的比较</h2> <table><thead><tr><th></th> <th>底层结构</th> <th>增删的效率</th> <th>改查的效率</th></tr></thead> <tbody><tr><td>ArrayList</td> <td>可变数组</td> <td>较低 数组扩容</td> <td>较高</td></tr> <tr><td>LinkedList</td> <td>双向链表</td> <td>较高，通过链表追加</td> <td>较低</td></tr></tbody></table> <blockquote><p>如何选择ArrayList和LinkedList：</p></blockquote> <ol><li>改查的操作多，选择ArrayList</li> <li>增删的操作多，选择LinkedList</li> <li>一般来说在程序中，80%~90%都是查询，因此大部分情况下回选择ArrayList</li></ol> <h2 id="set接口基本介绍"><a href="#set接口基本介绍" class="header-anchor">#</a> Set接口基本介绍</h2> <ol><li>无序（添加和取出的顺序不一致），没有索引</li> <li>不允许重复元素，所以最多包含一个null</li> <li>JDK ADI中Set接口实现类： HashSet、TreeSet</li></ol> <h3 id="set接口实现类-hashset-2"><a href="#set接口实现类-hashset-2" class="header-anchor">#</a> Set接口实现类-HashSet</h3> <ol><li>HashSet实现了Set接口</li> <li>HashSet实际上是HashMao</li> <li>可以存放null值，但是只能又一个null</li> <li>HashSet不保证元素是有序的，取决于hash后，在确定索引的结果</li> <li>不能有重复元素/对象</li></ol> <h3 id="set接口实现类-linkedhashset"><a href="#set接口实现类-linkedhashset" class="header-anchor">#</a> Set接口实现类-LinkedHashSet</h3> <ol><li>LinkedHashSet是HashSet的子类</li> <li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</li> <li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置同时使用链表
维护元素的次序，使得元素看起来是以插入顺序保存</li> <li>LinkedHashSet不允许添加重复元素</li></ol> <h2 id="map接口和常用方法"><a href="#map接口和常用方法" class="header-anchor">#</a> Map接口和常用方法</h2> <blockquote><p>Map接口实现类的特点</p></blockquote> <ol><li>Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value</li> <li>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</li> <li>Map中的key不允许重复</li> <li>Map中的value可以重复</li> <li>Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null可以多个</li> <li>常用String类作为Map中的key</li> <li>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</li> <li>Map存放数据的key-value</li></ol> <blockquote><p>Map接口常用方法</p></blockquote> <ol><li>put:添加</li> <li>remove：根据键删除映射关系</li> <li>get：根据键获取值</li> <li>size：获取元素个数</li> <li>isEmpty：判断个数是否为0</li> <li>clear：清楚</li> <li>containsKey：查找键是否存在</li></ol> <h2 id="map六大遍历方式"><a href="#map六大遍历方式" class="header-anchor">#</a> Map六大遍历方式</h2> <h2 id="hashtable"><a href="#hashtable" class="header-anchor">#</a> HashTable</h2> <ol><li>存放的元素是键值对</li> <li>HashTable的键和值都不能为null</li> <li>HashTable使用方法和HashMap一样</li> <li>HashTable是线程安全的（synchronized），HashMap是线程不安全的</li></ol> <h2 id="map接口实现类-properties"><a href="#map接口实现类-properties" class="header-anchor">#</a> Map接口实现类-Properties</h2> <ol><li>Properties类继承自HashTable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</li> <li>使用特点和HashTable类似</li> <li>Properties可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</li></ol> <blockquote><p>开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性
进行选择，分析如下：</p></blockquote> <ol><li>先判断存储的类型（一组对象[单例]或一组键值对[双例]）</li> <li>一组对象[单例]：Collection接口
允许重复：List
增删多：LinkedList [底层维护一个双向链表]
改查多：ArrayList[底层维护Object类型的可变数组]
不允许重复：Set
无序：HashSet[底层是HashMap，维护了一个哈希表即数组+链表+红黑树]
排序:TreeSet
插入和取出顺序一致：LinkedHashSet，维护数组+双向链表</li> <li>一组键值对双例：Map
键无序：HashMap [底层是：哈希表 jdk7：数组+链表 jdk8：数组+链表+红黑树]
键排序：TreeMap
键插入和取出顺序一致：LinkedHashMap
读出文件 Properties</li></ol> <h2 id="collections工具类"><a href="#collections工具类" class="header-anchor">#</a> Collections工具类</h2> <blockquote><p>Collections工具类介绍</p></blockquote> <ol><li>Collections是一个操作Set、List和Map等集合的工具类</li> <li>Collections中提供了一系列静态方法对集合元素进行排序、查询和修改等操作</li></ol> <p>排序操作：</p> <ol><li>reverse(List)：反转List中元素的顺序</li> <li>shuffle(List)：对List集合元素进行随机排序</li> <li>sort(List)：根据元素的自然顺序对指定List集合按升序排序</li> <li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li> <li>swap(List,int,int)：将指定list集合中的i处元素个j处元素进行交换</li></ol> <p>查找、替换</p> <ol><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li> <li>Object max(Collection,Comparator)根据Comparator指定的顺序，返回给定集合中的最大元素</li> <li>Object min(Collection)</li> <li>Object min(Collection,Comparator)</li> <li>int frequency(Collection,Object)：返回指定集合中指定元素的出现次数</li> <li>void copy(List dest,List src)将src中的内容复制到dest中</li> <li>boolean replaceAll(List list,Object oldVal,Object newVal)使用新值替换List对象的所有旧值</li></ol> <h1 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h1> <p>使用传统方法的问题分析</p> <ol><li>不能对加入到集合ArrayList中的数据类型进行约束（不安全）</li> <li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响</li></ol> <blockquote><p>泛型的好处</p></blockquote> <ol><li>编译时，检查添加元素的类型，提高安全性</li> <li>减少类型转换的次数，提高效率</li> <li>不在提示编译警告</li></ol> <p>泛型介绍</p> <ol><li>泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题</li> <li>在类声明或实例化时只要指定好需要的具体的类型即可</li> <li>java泛型可以保证如果程序存在编译时没有发出警告，运行时就不会产生ClassCastException异常。
同时代码更加简洁、健壮</li> <li>泛型的作用是：可以在类声明时通过一个标识表示类某个属性的类型，或者是某个方法的返回值的类型，
或者是参数类型。</li></ol> <p>泛型的语法</p> <blockquote><p>声明
interface 接口<T>{} 和 class类&lt;K,V&gt;{}
说明：</T></p></blockquote> <ol><li>其中，T,K,V不代表值，而是表示类型</li> <li>任意字母都可以。常用T表示，是Type的缩写</li></ol> <blockquote><p>泛型的实例化：
要在类名后面指定类型参数的值（类型）。如：</p></blockquote> <ol><li>List<String> strList = new ArrayList<String>();</String></String></li> <li>Iterator<Customer> iterator = customers.iterator();</Customer></li></ol> <h2 id="泛型使用的注意事项和细节"><a href="#泛型使用的注意事项和细节" class="header-anchor">#</a> 泛型使用的注意事项和细节</h2> <ol><li>interface list<T>{},public class HashSet<E>{}...等等说明
T，E只能是引用类型</E></T></li></ol> <div class="language- extra-class"><pre class="language-text"><code>List&lt;int&gt; list2 = new ArrayList&lt;int&gt;();//错误
</code></pre></div><ol start="2"><li>在给泛型具体类型后，可以传入该类型或者其子类类型</li> <li>List list2 = new ArrayList&lt;&gt;();//默认泛型是Object</li></ol> <h2 id="自定义泛型"><a href="#自定义泛型" class="header-anchor">#</a> 自定义泛型</h2> <blockquote><p>基本语法
class 类名&lt;T,R...&gt;{
成员
}</p></blockquote> <blockquote><p>注意细节</p></blockquote> <ol><li>普通成员可以使用泛型(属性、方法)</li> <li>使用泛型的数组，不能初始化</li> <li>静态方法中不能使用类的泛型</li> <li>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）</li> <li>如果再创建对象时，没有指定类型，默认为Object</li></ol> <h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="header-anchor">#</a> 自定义泛型接口</h2> <blockquote><p>基本语法
interface 接口名&lt;T,R...&gt;{
}</p></blockquote> <blockquote><p>注意细节</p></blockquote> <ol><li>接口中，静态成员也不能使用泛型</li> <li>泛型接口的类型，在继承接口或者实现接口时确定</li> <li>没有指定类型，默认为Object</li></ol> <h1 id="线程"><a href="#线程" class="header-anchor">#</a> 线程</h1> <h2 id="释放锁的分析"><a href="#释放锁的分析" class="header-anchor">#</a> 释放锁的分析</h2> <ol><li>当前线程的同步方法，同步代码执行借宿</li> <li>当前线程在同步代码块、同步方法中遇到break、return</li> <li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li> <li>当前线程在同步代码块、同步方法中执行了线程对象的wait（）方法。当前线程暂停，并释放锁</li></ol> <blockquote><p>以下操作不会释放锁</p></blockquote> <ol><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法
暂停当前线程的执行、不会释放锁</li> <li>线程执行同步代码时，其他线程调用了该线程的suspend（）方法将该线程挂起，该线程不会释放锁</li></ol> <h1 id="线程相关概念"><a href="#线程相关概念" class="header-anchor">#</a> 线程相关概念</h1> <ol><li>单线程：同一时刻，只允许执行一个线程</li> <li>多线程：同一时刻，可以执行多个线程</li> <li>并发：同一个时刻，多个任务交替执行，单核cpu实现的多个任务就是并发</li> <li>并行：同一个时刻，多个任务同时执行。多核cpu可以实现并行。</li></ol> <h2 id="常用方法"><a href="#常用方法" class="header-anchor">#</a> 常用方法</h2> <ol><li>setName //设置线程名称，使之与参数那么相同</li> <li>getName //返回线程的，名称</li> <li>start //使该线程开始执行；java虚拟机底层调用该线程的start0方法</li> <li>run //调用线程对象run方法</li> <li>setPriority //更改线程优先级</li> <li>getPriority //获取线程的优先级</li> <li>sleep //在指定的毫秒内让当前正在执行的线程休眠（暂停执行）</li> <li>interrupt //中断线程</li> <li>setDaemon //设置守护线程</li></ol> <h2 id="常用方法2"><a href="#常用方法2" class="header-anchor">#</a> 常用方法2</h2> <ol><li><p>yield:线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，
所以也不一定礼让成功</p></li> <li><p>join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程
所有的任务</p></li></ol> <h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="header-anchor">#</a> 用户线程和守护线程</h2> <ol><li>用户线程：也叫工作线程，当线程的任务执行完或通知方法结束</li> <li>守护线程：一般是为工作线程服务的，当所有用户线程结束，守护线程自动结束（eg:垃圾回收机制）</li></ol> <h2 id="线程7大状态"><a href="#线程7大状态" class="header-anchor">#</a> 线程7大状态</h2> <h2 id="线程同步机制"><a href="#线程同步机制" class="header-anchor">#</a> 线程同步机制</h2> <p>同步具体方法-Synchronized</p> <ol><li>同步代码块
synchronized(对象){ //得到对象的锁，才能操作同步代码
//需要被同步代码；
}</li> <li>synchronized还可以放在方法声明中，表示整个方法-为同步方法</li></ol> <div class="language- extra-class"><pre class="language-text"><code> public synchronized void m(String name){
        //需要被同步的代码
 }
</code></pre></div><h2 id="互斥锁"><a href="#互斥锁" class="header-anchor">#</a> 互斥锁</h2> <blockquote><p>二进制文件
声音，视频，word文档，pdf</p></blockquote> <h2 id="节点流和处理流"><a href="#节点流和处理流" class="header-anchor">#</a> 节点流和处理流</h2> <p>对象流 ObjectInputStream和ObjectOutputStream</p> <blockquote><p>序列化和反序列化</p></blockquote> <ol><li>序列化就是在保存数据时，保存数据的值和数据类型</li> <li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li> <li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该
类必须实现如下两个接口之一：
<ul><li>Serializable //这是一个标记接口,里面没有方法（推荐）</li> <li>Externalizable</li></ul></li></ol> <blockquote><p>注意事项和细节说明</p></blockquote> <ol><li>读写顺序要一致</li> <li>要求序列化或反序列化对象，需要实现 Serializable</li> <li>序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性</li> <li>序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员</li> <li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li> <li>序列化具备可继承性</li></ol> <blockquote><p>标准输入输出流</p></blockquote> <table><thead><tr><th>--</th> <th>类型</th> <th>默认设备</th></tr></thead> <tbody><tr><td>System.in 标准输入</td> <td>InputStream</td> <td>键盘</td></tr> <tr><td>System.out 标准输出</td> <td>PrintStream</td> <td>显示器</td></tr></tbody></table> <blockquote><p>转换流 InputStreamReader 和 OutputStreamWriter</p></blockquote> <ul><li>介绍</li></ul> <ol><li>InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</li> <li>OutputStreamWriter：Writer的子类，实现将OutputStream（字节流）包装成Writer（字符流）</li> <li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议
将字节流转换成字符流</li> <li>可以在使用时指定编码格式（比如 utf-8，gbk，gb2312，ISO8859-1等）</li></ol> <h2 id="网络相关概念"><a href="#网络相关概念" class="header-anchor">#</a> 网络相关概念</h2> <ul><li>ip地址</li> <li>域名和端口</li> <li>网络协议</li> <li>TCP和UDP</li> <li>InetAddress类</li></ul> <blockquote><p>相关方法</p></blockquote> <ol><li>获取本机InetAddress对象getLocalHost</li> <li>根据指定主机名/域名获取ip地址对象getByName</li> <li>获取InetAddresst对象的主机名getHostName</li> <li>获取InetAddress对象的地址getHostAddress</li></ol> <h1 id="流"><a href="#流" class="header-anchor">#</a> 流</h1> <h1 id="文件基础知识"><a href="#文件基础知识" class="header-anchor">#</a> 文件基础知识</h1> <blockquote><p>创建文件对象相关构造器和方法</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>new File(String pathname)//根据路径构建一个File对象
new File(File parent,String child)//根据父目录文件+子路径构建
new File(String parent,String child)//根据父目录+子路径构建
</code></pre></div><h2 id="io流原理及流的分类"><a href="#io流原理及流的分类" class="header-anchor">#</a> IO流原理及流的分类</h2> <blockquote><p>流的分类</p></blockquote> <ul><li>按操作数据单位不同分类为：字节流（8bit）二进制文件，字符流（按字符）文本文件</li> <li>按数据流的流向不同分为：输入流，输出流</li> <li>按流的角色的不同分类：节点流，处理流/包装流</li></ul> <table><thead><tr><th>（抽象基类）</th> <th>字节流</th> <th>字符流</th></tr></thead> <tbody><tr><td>输入流</td> <td>InputStream</td> <td>Reader</td></tr> <tr><td>输出流</td> <td>OutputStream</td> <td>Writer</td></tr></tbody></table> <h2 id="io流常用体系图-常用类"><a href="#io流常用体系图-常用类" class="header-anchor">#</a> IO流常用体系图-常用类</h2> <p>FileInputStream
FileOutputStream</p> <blockquote><p>FileReader和FileWriter介绍</p></blockquote> <p>FileReader和FileWriter是字符流，即按照字符来操作io</p> <blockquote><p>FileReader相关方法</p></blockquote> <ol><li>new FileReader（File/String）</li> <li>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</li> <li>read（char[]）：批量读取多个字符到数组，返回读取的字符数，如果到文件末尾返回-1
相关 API:</li> <li>new String（char[]):将char[]转换成String</li> <li>new String（char[],off,len):将char[]的指定部分转换成String</li></ol> <blockquote><p>FileWriter相关方法</p></blockquote> <ol><li>new FileWriter（File/String）:覆盖模式，相当于流的指针在首端</li> <li>new FileWriter（File/String,true）:追加模式，相当于流的指针在尾端</li> <li>writer(int)：写入单个字符</li> <li>writer(char[])：写入指定数组</li> <li>writer(char[],off,len)；写入数组的指定部分</li> <li>writer(string)；写入整个字符串</li> <li>writer(string,off,len)；写入字符串的指定部分
相关 API:String类： toCharArray：将String转换成char[]</li></ol> <blockquote><p>注意
FileWriter使用后，必须关闭(close)或刷新(flush)，否则写入不到指定的文件</p></blockquote> <h2 id="节点流和处理流-2"><a href="#节点流和处理流-2" class="header-anchor">#</a> 节点流和处理流</h2> <blockquote><p>基本介绍</p></blockquote> <ol><li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</li> <li>处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter</li></ol> <h2 id="节点和处理流的区别和联系"><a href="#节点和处理流的区别和联系" class="header-anchor">#</a> 节点和处理流的区别和联系</h2> <ol><li>节点流是底层流/低级流，直接跟数据源相接</li> <li>处理流（包装流）包装节点流，即可消除不同节点流的实现差异，也可以提供更
方便的方法来完成输入输出</li> <li>处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连</li></ol> <p>处理流的功能主要体现在以下两个方面：</p> <ol><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li> <li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li></ol> <h2 id="打印流-printstream和printwriter"><a href="#打印流-printstream和printwriter" class="header-anchor">#</a> 打印流-PrintStream和PrintWriter</h2> <h2 id="properties类"><a href="#properties类" class="header-anchor">#</a> Properties类</h2> <p>基本介绍</p> <ol><li>专门用于读写配置文件的集合类
配置文件的格式：
键=值
键=值</li> <li>注意：键值对不需要有空格，之不需要用引号引起来，默认类型是String</li></ol> <h1 id="反射"><a href="#反射" class="header-anchor">#</a> 反射</h1> <h2 id="java反射机制可以完成"><a href="#java反射机制可以完成" class="header-anchor">#</a> java反射机制可以完成</h2> <p>1.在运行时判断任意一个对象所属的类
2.在运行时构造任意一个类的对象
3.在运行时得到任意一个类所具有的成员变量和方法
4.在运行时调用任意一个对象的成员变量和方法
5.生成动态代理</p> <h2 id="反射主要的类"><a href="#反射主要的类" class="header-anchor">#</a> 反射主要的类</h2> <p>1.java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象
2.java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法
3.java.lang.reflect.Field:代表类的成员变量，Field对象表示某个类的成员变量
4.java.lang.reflect.Constructor:代表类的构造方法，Constructor对象表示构造器</p> <h2 id="反射的优点和缺点"><a href="#反射的优点和缺点" class="header-anchor">#</a> 反射的优点和缺点</h2> <ol><li>优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有
反射机制，框架技术就失去底层支撑。</li> <li>缺点：使用反射基本是解释执行，对执行速度有影响</li></ol> <h2 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="header-anchor">#</a> 反射调用优化-关闭访问检查</h2> <ol><li>Method和Filed、Constructor对象都拥有setAccessible()方法</li> <li>setAccessible作用是启动和禁用访问安全检查的开关</li> <li>参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率，参数值
为false则表示反射的对象执行访问检查</li></ol> <h2 id="class类分析"><a href="#class类分析" class="header-anchor">#</a> Class类分析</h2> <ol><li>Class也是类，因此也继承Object类</li> <li>Class类对象不是new出来的，而是系统创建的</li> <li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li> <li>每个类的实例都会记得自己是由那个Class实例所生成</li> <li>通过Class可以完整地得到一个类的完整结构，通过一系列API</li> <li>Class对象存放在堆</li> <li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等）</li></ol> <h2 id="java反射机制原理示意图"><a href="#java反射机制原理示意图" class="header-anchor">#</a> Java反射机制原理示意图</h2> <h2 id="class类常用方法"><a href="#class类常用方法" class="header-anchor">#</a> Class类常用方法</h2> <table><thead><tr><th>方法名</th> <th>功能说明</th></tr></thead> <tbody><tr><td>staic Class forName(String name)</td> <td>放回指定类名name的Class对象</td></tr> <tr><td>Object newInstance()</td> <td>调用缺省构造函数，返回该Class对象的一个实例</td></tr> <tr><td>getName()</td> <td>返回此Class对象所表示的实体(类、接口、数组类、基本类型等）名称</td></tr> <tr><td>Class[] getInterfaces()</td> <td>获取当前Class对象的接口</td></tr> <tr><td>ClassLoader getClassLoader()</td> <td>返回该类的类加载器</td></tr> <tr><td>Class getSuperclass()</td> <td>返回表示此Class所表示的实体的超类的Class</td></tr> <tr><td>Constructor[] getConstructors()</td> <td>返回一个包含某些Constructor对象的数组</td></tr> <tr><td>Field[] getDeclaredFields()</td> <td>返回Field对象的一个数组</td></tr> <tr><td>Method getMethod（String name,Class ... paramTypes)</td> <td>返回一个Method对象，此对象的形参类型为paramType</td></tr></tbody></table> <h2 id="获取class类对象"><a href="#获取class类对象" class="header-anchor">#</a> 获取Class类对象</h2> <ol><li><p>前提：已知一个类的全类名，且该类在类路锦下，可通过Class类的静态方法forName（）获取
实例：Class cls1 = Class.forName(&quot;&quot;java.lang.Cat&quot;);
应用场景：多用于配置文件，读取类全路径，加载类</p></li> <li><p>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能
最高实例：Class cls2 = Cat.class；
应用场景：多用于参数传递，比如通过反射得到对应构造器对象</p></li> <li><p>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象，实例：
Class clazz = 对象.getClass();
应用场景：通过创建好的对象，获取Class对象</p></li> <li><p>其他方式(类加载器)
ClassLoader cl = 对象.getClass().getClassLoader();
Class clazz4 = cl.loadClass(&quot;类的全类名&quot;);</p></li> <li><p>基本数据按如下方式得到Class类对象
Class cls = 基本数据类型.class</p></li> <li><p>基本数据类型对应的包装类，可以通过.type得到Class类对象
Class cls = 包装类.TYPE</p></li></ol> <h2 id="如下类型有class对象"><a href="#如下类型有class对象" class="header-anchor">#</a> 如下类型有Class对象</h2> <ol><li>外部类，成员内部类，静态内部类，局部内部类。匿名内部类</li> <li>interface：接口</li> <li>数组</li> <li>enum：枚举</li> <li>annotation：注解</li> <li>基本数据类型</li> <li>void</li></ol> <h1 id="类加载"><a href="#类加载" class="header-anchor">#</a> 类加载</h1> <h2 id="基本说明"><a href="#基本说明" class="header-anchor">#</a> 基本说明</h2> <p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p> <ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li> <li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol> <h2 id="类加载时机"><a href="#类加载时机" class="header-anchor">#</a> 类加载时机</h2> <ol><li>当创建对象时（new） //静态加载</li> <li>当子类被加载时，父类也加载 //静态加载</li> <li>调用类中的静态成员时 //静态加载</li> <li>通过反射 //动态加载</li></ol> <h2 id="类加载的五个阶段"><a href="#类加载的五个阶段" class="header-anchor">#</a> 类加载的五个阶段</h2> <ul><li><p>加载阶段</p> <p>JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是
jar包、甚至网络）转换为二进制字节流加载到内存，并生成一个代表类的java.lang.Class对象</p></li> <li><p>连接阶段-验证</p></li></ul> <ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会
危害虚拟机自身的安全</li> <li>包括：文件格式验证（是否以魔数 ox cafebabe开头）、元数据验证、字节码验证和符号引用验证</li> <li>可以考虑使用 -Xverify:none参数来关闭大部分的类验证设施，缩短虚拟机类加载的时间</li></ol> <ul><li>连接阶段——准备</li></ul> <ol><li>JVM会在该阶段对静态变量，分配内存并初始化（对应数据类型的默认初始值
如0、0L、null、false等）。这些变量所使用的内存都将在方法区中进行分配</li></ol> <ul><li>连接阶段——解析</li></ul> <ol><li>虚拟机将常量池内的符号引用替换为直接引用的过程</li></ol> <ul><li>Initialization(初始化)</li></ul> <ol><li>到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程</clinit></li> <li><clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有
静态变量的赋值动作和静态代码块中的语句，并进行合并</clinit></li> <li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时取初始化一个类
，那么只会有一个线程取执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕</clinit></clinit></clinit></li></ol> <h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="header-anchor">#</a> 通过反射获取类的结构信息</h2> <h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="header-anchor">#</a> 通过反射创建对象</h2> <ol><li>方式一：调用类中的public修饰的无参构造器</li> <li>方式二：调用类中的指定构造器</li> <li>Class类相关方法</li></ol> <ul><li>newInstance：调用类中的无参构造器，获取对应类的对象</li> <li>getConstructor(Class..clazz):根据参数列表，获取对应的public构造器对象</li> <li>getDeclaredConstructor(Class..clazz)根据参数列表，获取对应的所有构造器对象</li></ul> <ol start="4"><li>Constructor类相关方法</li></ol> <ul><li>setAccessible:爆破</li> <li>newInstance(Object...obj):调用构造器</li></ul> <h2 id="通过反射访问类中的属性"><a href="#通过反射访问类中的属性" class="header-anchor">#</a> 通过反射访问类中的属性</h2> <ol><li>根据属性名获取Field对象
Field f = clazz对象.getDeclaredField(属性名);</li> <li>爆破：f.setAccessible(true); f是Field</li> <li>访问
f.set(o,值);//o表示对象</li> <li>注意：如果是静态属性，则set和get中的参数0，可以写成null</li></ol> <h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="header-anchor">#</a> 通过反射访问类中的成员</h2> <ol><li>根据方法名和参数列表后去Method方法对象：
Method m = clazz.getDeclaredMethod(方法名，XX。class);//得到本类的所有方法</li> <li>获取对象：Object 0 = clazz.newInstance();</li> <li>爆破：m.setAccessible(true);</li> <li>访问：Object returnValue = m.invoke(o,实参列表);//o就是对象</li> <li>注意：如果是静态方法，则invoke的参数o，可以写成null</li></ol> <h1 id="java8新特性"><a href="#java8新特性" class="header-anchor">#</a> java8新特性</h1> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <ul><li>速度更快</li> <li>代码更少（增加了新的语法：Lambda表达式）</li> <li>强大的Stream API</li> <li>便于并行</li> <li>最大化减少空指针异常：Optional</li> <li>Nashorn引擎，允许在JVM上运行JS应用(jjs)</li></ul> <p>并行流与串行流
并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。
相比较串行的流，并行的流可以很大程序上提高程序的执行效率</p> <p>java8中将并行进行了优化，可以很容易的对数据进行并行操作。StreamAPI可以声明性
地通过paralle()与sequential()在并行流与顺序流之间进行切换</p> <ol><li>Lambda表达式</li> <li>函数式接口</li> <li>方法引用与构造器引用</li> <li>强大的StreamAPI</li> <li>Optional类</li></ol> <h2 id="lambda表达式语法"><a href="#lambda表达式语法" class="header-anchor">#</a> Lambda表达式语法</h2> <ol><li><p>举例：(o1，o2) -&gt; Integer.compare(o1,o2);</p></li> <li><p>格式：
-&gt; :lambda操作符或箭头操作符
-&gt; 左边：lambda形参列表（其实就是接口中的抽象方法的形参列表）
-&gt; 右边：lambda体（其实就是重写的抽象方法的方法体）</p></li> <li><p>表达式的使用：
总结
左边：lambda形参列表的参数类型可以省略（类型推断）；如果lambda形参列表只有一个参数，其一对（）也可以省略
右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p></li> <li><p>lambda表达式的本质：作为接口的实列</p></li> <li><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用@Functionallnterface注解，这样可以
检查它是否一个函数式接口</p></li> <li><p>用匿名实现类表示的现在都可以用Lambda表达式替换</p></li></ol> <h2 id="java操作mysql数据库"><a href="#java操作mysql数据库" class="header-anchor">#</a> java操作mysql数据库</h2> <blockquote><p>java内置的4大核心函数式接口</p></blockquote> <ul><li>消费型接口 Consumer<T>    void accept(T t)</T></li> <li>供给型接口 Supplier<T>    T get()</T></li> <li>函数型接口 Function&lt;T,R&gt;  R apply(T,t)</li> <li>断定型接口 Predicate<T>   boolean test(T t)</T></li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/java/spring注解.html">
          spring
        </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-ac050c62><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#常用的包" class="sidebar-link reco-side-常用的包" data-v-ac050c62>常用的包</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#包的使用细节" class="sidebar-link reco-side-包的使用细节" data-v-ac050c62>包的使用细节</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#注意事项和使用细节" class="sidebar-link reco-side-注意事项和使用细节" data-v-ac050c62>注意事项和使用细节</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#方法重写和重载比较" class="sidebar-link reco-side-方法重写和重载比较" data-v-ac050c62>方法重写和重载比较</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#多态注意事项和细节讨论" class="sidebar-link reco-side-多态注意事项和细节讨论" data-v-ac050c62>多态注意事项和细节讨论</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#多态的向下转型" class="sidebar-link reco-side-多态的向下转型" data-v-ac050c62>多态的向下转型</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#java的动态绑定机制-非常非常重要" class="sidebar-link reco-side-java的动态绑定机制-非常非常重要" data-v-ac050c62>java的动态绑定机制（非常非常重要）</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#多态应用" class="sidebar-link reco-side-多态应用" data-v-ac050c62>多态应用</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#和-equals的对比" class="sidebar-link reco-side-和-equals的对比" data-v-ac050c62>== 和 equals的对比</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#hashcode方法" class="sidebar-link reco-side-hashcode方法" data-v-ac050c62>hashCode方法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#tostring" class="sidebar-link reco-side-tostring" data-v-ac050c62>toString</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#finalize方法-开发中使用较少" class="sidebar-link reco-side-finalize方法-开发中使用较少" data-v-ac050c62>finalize方法（开发中使用较少）</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类变量和类方法" class="sidebar-link reco-side-类变量和类方法" data-v-ac050c62>类变量和类方法</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#什么是类变量" class="sidebar-link reco-side-什么是类变量" data-v-ac050c62>什么是类变量</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#如何定义类变量" class="sidebar-link reco-side-如何定义类变量" data-v-ac050c62>如何定义类变量</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类变量的内存布局-跟jdk版本有关" class="sidebar-link reco-side-类变量的内存布局-跟jdk版本有关" data-v-ac050c62>类变量的内存布局（跟jdk版本有关）</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类变量的使用注意事项和细节" class="sidebar-link reco-side-类变量的使用注意事项和细节" data-v-ac050c62>类变量的使用注意事项和细节</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类方法基本介绍" class="sidebar-link reco-side-类方法基本介绍" data-v-ac050c62>类方法基本介绍</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#如何定义类变量-2" class="sidebar-link reco-side-如何定义类变量-2" data-v-ac050c62>如何定义类变量</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类方法使用注意事项和细节" class="sidebar-link reco-side-类方法使用注意事项和细节" data-v-ac050c62>类方法使用注意事项和细节</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#main方法" class="sidebar-link reco-side-main方法" data-v-ac050c62>main方法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#代码块" class="sidebar-link reco-side-代码块" data-v-ac050c62>代码块</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#单例模式" class="sidebar-link reco-side-单例模式" data-v-ac050c62>单例模式</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#final关键字" class="sidebar-link reco-side-final关键字" data-v-ac050c62>final关键字</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#抽象类" class="sidebar-link reco-side-抽象类" data-v-ac050c62>抽象类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#接口" class="sidebar-link reco-side-接口" data-v-ac050c62>接口</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#局部内部类的使用" class="sidebar-link reco-side-局部内部类的使用" data-v-ac050c62>局部内部类的使用</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#匿名内部类-重点" class="sidebar-link reco-side-匿名内部类-重点" data-v-ac050c62>匿名内部类（重点）</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#成员内部类" class="sidebar-link reco-side-成员内部类" data-v-ac050c62>成员内部类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#静态内部类" class="sidebar-link reco-side-静态内部类" data-v-ac050c62>静态内部类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#try-catch" class="sidebar-link reco-side-try-catch" data-v-ac050c62>try-catch</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#throw异常处理" class="sidebar-link reco-side-throw异常处理" data-v-ac050c62>throw异常处理</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#string类" class="sidebar-link reco-side-string类" data-v-ac050c62>String类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#math类" class="sidebar-link reco-side-math类" data-v-ac050c62>Math类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#arrays类" class="sidebar-link reco-side-arrays类" data-v-ac050c62>Arrays类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#system类" class="sidebar-link reco-side-system类" data-v-ac050c62>System类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#大数据处理" class="sidebar-link reco-side-大数据处理" data-v-ac050c62>大数据处理</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#日期类-了解即可" class="sidebar-link reco-side-日期类-了解即可" data-v-ac050c62>日期类（了解即可）</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#set接口实现类-hashset" class="sidebar-link reco-side-set接口实现类-hashset" data-v-ac050c62>Set接口实现类-HashSet</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#collection接口和常用方法" class="sidebar-link reco-side-collection接口和常用方法" data-v-ac050c62>Collection接口和常用方法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#list接口" class="sidebar-link reco-side-list接口" data-v-ac050c62>List接口</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#arraylist底层结构和源码分析-重点-难点" class="sidebar-link reco-side-arraylist底层结构和源码分析-重点-难点" data-v-ac050c62>ArrayList底层结构和源码分析（重点，难点）</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#vector底层结构和源码分析" class="sidebar-link reco-side-vector底层结构和源码分析" data-v-ac050c62>Vector底层结构和源码分析</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#linkedlist的底层结构" class="sidebar-link reco-side-linkedlist的底层结构" data-v-ac050c62>LinkedList的底层结构</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#arraylist和linkedlist的比较" class="sidebar-link reco-side-arraylist和linkedlist的比较" data-v-ac050c62>ArrayList和LinkedList的比较</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#set接口基本介绍" class="sidebar-link reco-side-set接口基本介绍" data-v-ac050c62>Set接口基本介绍</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#set接口实现类-hashset-2" class="sidebar-link reco-side-set接口实现类-hashset-2" data-v-ac050c62>Set接口实现类-HashSet</a></li><li class="level-3" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#set接口实现类-linkedhashset" class="sidebar-link reco-side-set接口实现类-linkedhashset" data-v-ac050c62>Set接口实现类-LinkedHashSet</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#map接口和常用方法" class="sidebar-link reco-side-map接口和常用方法" data-v-ac050c62>Map接口和常用方法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#map六大遍历方式" class="sidebar-link reco-side-map六大遍历方式" data-v-ac050c62>Map六大遍历方式</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#hashtable" class="sidebar-link reco-side-hashtable" data-v-ac050c62>HashTable</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#map接口实现类-properties" class="sidebar-link reco-side-map接口实现类-properties" data-v-ac050c62>Map接口实现类-Properties</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#collections工具类" class="sidebar-link reco-side-collections工具类" data-v-ac050c62>Collections工具类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#泛型使用的注意事项和细节" class="sidebar-link reco-side-泛型使用的注意事项和细节" data-v-ac050c62>泛型使用的注意事项和细节</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#自定义泛型" class="sidebar-link reco-side-自定义泛型" data-v-ac050c62>自定义泛型</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#自定义泛型接口" class="sidebar-link reco-side-自定义泛型接口" data-v-ac050c62>自定义泛型接口</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#释放锁的分析" class="sidebar-link reco-side-释放锁的分析" data-v-ac050c62>释放锁的分析</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#常用方法" class="sidebar-link reco-side-常用方法" data-v-ac050c62>常用方法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#常用方法2" class="sidebar-link reco-side-常用方法2" data-v-ac050c62>常用方法2</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#用户线程和守护线程" class="sidebar-link reco-side-用户线程和守护线程" data-v-ac050c62>用户线程和守护线程</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#线程7大状态" class="sidebar-link reco-side-线程7大状态" data-v-ac050c62>线程7大状态</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#线程同步机制" class="sidebar-link reco-side-线程同步机制" data-v-ac050c62>线程同步机制</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#互斥锁" class="sidebar-link reco-side-互斥锁" data-v-ac050c62>互斥锁</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#节点流和处理流" class="sidebar-link reco-side-节点流和处理流" data-v-ac050c62>节点流和处理流</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#网络相关概念" class="sidebar-link reco-side-网络相关概念" data-v-ac050c62>网络相关概念</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#io流原理及流的分类" class="sidebar-link reco-side-io流原理及流的分类" data-v-ac050c62>IO流原理及流的分类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#io流常用体系图-常用类" class="sidebar-link reco-side-io流常用体系图-常用类" data-v-ac050c62>IO流常用体系图-常用类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#节点流和处理流-2" class="sidebar-link reco-side-节点流和处理流-2" data-v-ac050c62>节点流和处理流</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#节点和处理流的区别和联系" class="sidebar-link reco-side-节点和处理流的区别和联系" data-v-ac050c62>节点和处理流的区别和联系</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#打印流-printstream和printwriter" class="sidebar-link reco-side-打印流-printstream和printwriter" data-v-ac050c62>打印流-PrintStream和PrintWriter</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#properties类" class="sidebar-link reco-side-properties类" data-v-ac050c62>Properties类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#java反射机制可以完成" class="sidebar-link reco-side-java反射机制可以完成" data-v-ac050c62>java反射机制可以完成</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#反射主要的类" class="sidebar-link reco-side-反射主要的类" data-v-ac050c62>反射主要的类</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#反射的优点和缺点" class="sidebar-link reco-side-反射的优点和缺点" data-v-ac050c62>反射的优点和缺点</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#反射调用优化-关闭访问检查" class="sidebar-link reco-side-反射调用优化-关闭访问检查" data-v-ac050c62>反射调用优化-关闭访问检查</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#class类分析" class="sidebar-link reco-side-class类分析" data-v-ac050c62>Class类分析</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#java反射机制原理示意图" class="sidebar-link reco-side-java反射机制原理示意图" data-v-ac050c62>Java反射机制原理示意图</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#class类常用方法" class="sidebar-link reco-side-class类常用方法" data-v-ac050c62>Class类常用方法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#获取class类对象" class="sidebar-link reco-side-获取class类对象" data-v-ac050c62>获取Class类对象</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#如下类型有class对象" class="sidebar-link reco-side-如下类型有class对象" data-v-ac050c62>如下类型有Class对象</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#基本说明" class="sidebar-link reco-side-基本说明" data-v-ac050c62>基本说明</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类加载时机" class="sidebar-link reco-side-类加载时机" data-v-ac050c62>类加载时机</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#类加载的五个阶段" class="sidebar-link reco-side-类加载的五个阶段" data-v-ac050c62>类加载的五个阶段</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#通过反射获取类的结构信息" class="sidebar-link reco-side-通过反射获取类的结构信息" data-v-ac050c62>通过反射获取类的结构信息</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#通过反射创建对象" class="sidebar-link reco-side-通过反射创建对象" data-v-ac050c62>通过反射创建对象</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#通过反射访问类中的属性" class="sidebar-link reco-side-通过反射访问类中的属性" data-v-ac050c62>通过反射访问类中的属性</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#通过反射访问类中的成员" class="sidebar-link reco-side-通过反射访问类中的成员" data-v-ac050c62>通过反射访问类中的成员</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#简介" class="sidebar-link reco-side-简介" data-v-ac050c62>简介</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#lambda表达式语法" class="sidebar-link reco-side-lambda表达式语法" data-v-ac050c62>Lambda表达式语法</a></li><li class="level-2" data-v-ac050c62><a href="/blog/java/java%E5%9F%BA%E7%A1%80.html#java操作mysql数据库" class="sidebar-link reco-side-java操作mysql数据库" data-v-ac050c62>java操作mysql数据库</a></li></ul></main></div> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.ed9cd75e.js" defer></script><script src="/blog/assets/js/3.24509252.js" defer></script><script src="/blog/assets/js/1.22e1a39c.js" defer></script><script src="/blog/assets/js/11.fdf41d93.js" defer></script>
  </body>
</html>

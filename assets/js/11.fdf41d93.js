(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{406:function(t,v,_){"use strict";_.r(v);var a=_(2),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#包"}},[t._v("#")]),t._v(" 包")]),t._v(" "),v("p",[t._v("命名规则：\n只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字")]),t._v(" "),v("p",[t._v("命名规范：\ncom.公司名.项目名.业务模块名")]),t._v(" "),v("h2",{attrs:{id:"常用的包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用的包"}},[t._v("#")]),t._v(" 常用的包")]),t._v(" "),v("p",[t._v("java.lang.* //lang是常用包，默认引入，不需要引入\njava utils //util包，系统提供的工具包，工具类\njava。net\t//网络包，网络开发\njava。awt //java界面开发")]),t._v(" "),v("h2",{attrs:{id:"包的使用细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#包的使用细节"}},[t._v("#")]),t._v(" 包的使用细节")]),t._v(" "),v("h1",{attrs:{id:"面向对象编程-继承-重点掌握"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程-继承-重点掌握"}},[t._v("#")]),t._v(" 面向对象编程-继承（重点掌握）")]),t._v(" "),v("p",[t._v("1、子类继承所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和\n方法不能在子类直接访问，要通过父类提供公共的方法去访问\n4、如果希望指定去调用父类的某个构造器，则显示的调用一下：spuer（参数列表）\n5、super在使用时，必须放在构造器第一行（spuer只能在构造器中使用）\n6、super（）和this（）都只能放在构造器第一行，因此这两个方法不能共存在一个构造器\n9、子类最多只能继承一个父类（指直接继承），即java中是单继承机制\n10、不能滥用继承，子类和父类之间必须满足is-a的逻辑关系")]),t._v(" "),v("h1",{attrs:{id:"super关键字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#super关键字"}},[t._v("#")]),t._v(" super关键字")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("No.")]),t._v(" "),v("th",[t._v("区别点")]),t._v(" "),v("th",[t._v("this")]),t._v(" "),v("th",[t._v("super")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("1")]),t._v(" "),v("td",[t._v("访问属性")]),t._v(" "),v("td",[t._v("访问本类中的属性，如果本类没有此属性则从父类中继续查找")]),t._v(" "),v("td",[t._v("从父类开始查找属性")])]),t._v(" "),v("tr",[v("td",[t._v("2")]),t._v(" "),v("td",[t._v("调用方法")]),t._v(" "),v("td",[t._v("访问本类中的方法，如果本类没有此方法则从父类继续查找")]),t._v(" "),v("td",[t._v("从父类开始查找")])]),t._v(" "),v("tr",[v("td",[t._v("3")]),t._v(" "),v("td",[t._v("调用构造器")]),t._v(" "),v("td",[t._v("调用本类构造器，必须放在构造器的首行")]),t._v(" "),v("td",[t._v("调用父类构造器，必须放在子类构造器的首行")])]),t._v(" "),v("tr",[v("td",[t._v("4")]),t._v(" "),v("td",[t._v("特殊")]),t._v(" "),v("td",[t._v("表示当前对象")]),t._v(" "),v("td",[t._v("子类中访问父类对象")])])])]),t._v(" "),v("h1",{attrs:{id:"方法重写-override"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法重写-override"}},[t._v("#")]),t._v(" 方法重写(override)")]),t._v(" "),v("h2",{attrs:{id:"注意事项和使用细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意事项和使用细节"}},[t._v("#")]),t._v(" 注意事项和使用细节")]),t._v(" "),v("p",[t._v("方法重写也叫方法覆盖，需要满足下面条件")]),t._v(" "),v("p",[t._v("1、子类的方法的形参列表、方法名臣，要和父类方法的形参列表，方法名称完全一样\n2、子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类\n比如 父类返回类型是Object，子类方法返回类型是String\n3、子类方法不能缩小父类方法的访问权限。（public -> protected -> 默认 -> private")]),t._v(" "),v("h2",{attrs:{id:"方法重写和重载比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法重写和重载比较"}},[t._v("#")]),t._v(" 方法重写和重载比较")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名称")]),t._v(" "),v("th",[t._v("发生范围")]),t._v(" "),v("th",[t._v("方法名")]),t._v(" "),v("th",[t._v("形参列表")]),t._v(" "),v("th",[t._v("返回类型")]),t._v(" "),v("th",[t._v("修饰符")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("重载（overload）")]),t._v(" "),v("td",[t._v("本类")]),t._v(" "),v("td",[t._v("必须一样")]),t._v(" "),v("td",[t._v("类型、个数或者顺序至少有一个不同")]),t._v(" "),v("td",[t._v("无需求")]),t._v(" "),v("td",[t._v("无需求")])]),t._v(" "),v("tr",[v("td",[t._v("重写（override）")]),t._v(" "),v("td",[t._v("父子类")]),t._v(" "),v("td",[t._v("必须一样")]),t._v(" "),v("td",[t._v("相同")]),t._v(" "),v("td",[t._v("子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类")]),t._v(" "),v("td",[t._v("子类方法不能缩小父类方法的访问范围")])])])]),t._v(" "),v("h1",{attrs:{id:"面向对象编程-多态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程-多态"}},[t._v("#")]),t._v(" 面向对象编程-多态")]),t._v(" "),v("h2",{attrs:{id:"多态注意事项和细节讨论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态注意事项和细节讨论"}},[t._v("#")]),t._v(" 多态注意事项和细节讨论")]),t._v(" "),v("ul",[v("li",[t._v("多态的前提是：两个对象（类）存在继承关系")]),t._v(" "),v("li",[t._v("多态的向上转型")])]),t._v(" "),v("ol",[v("li",[t._v("本质：父类的引用指向了子类的对象")]),t._v(" "),v("li",[t._v("语法：父类类型 引用名 = new 子类类型();")]),t._v(" "),v("li",[t._v("特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员\n（需遵守访问权限），不能调用子类中特有成员；最终运行效果看子类的具体实现（即调用\n方法时，按照子类（运行类型）开始查找方法，然后调用）")])]),t._v(" "),v("h2",{attrs:{id:"多态的向下转型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态的向下转型"}},[t._v("#")]),t._v(" 多态的向下转型")]),t._v(" "),v("ol",[v("li",[t._v("语法：子类类型 引用名 = （子类类型）父类引用；")]),t._v(" "),v("li",[t._v("只能强转父类的引用，不能强转父类的对象")]),t._v(" "),v("li",[t._v("要求父类的引用必须指向的是当前目标类型的对象")]),t._v(" "),v("li",[t._v("可以调用子类类型中所有的成员（属性和方法）")])]),t._v(" "),v("p",[t._v("属性没有重写之说，属性的值看编译类型。\ninstanceOf比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的\n子类型。")]),t._v(" "),v("h2",{attrs:{id:"java的动态绑定机制-非常非常重要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java的动态绑定机制-非常非常重要"}},[t._v("#")]),t._v(" java的动态绑定机制（非常非常重要）")]),t._v(" "),v("p",[t._v("java重要特性：动态绑定机制\njava的动态绑定机制")]),t._v(" "),v("ol",[v("li",[t._v("当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定")]),t._v(" "),v("li",[t._v("当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用")])]),t._v(" "),v("h2",{attrs:{id:"多态应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态应用"}},[t._v("#")]),t._v(" 多态应用")]),t._v(" "),v("ol",[v("li",[t._v("多态数组。数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。")]),t._v(" "),v("li",[t._v("多态参数。方法定义的形参类型为父类类型，实参类型允许为子类类型")])]),t._v(" "),v("h1",{attrs:{id:"object类详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#object类详解"}},[t._v("#")]),t._v(" Object类详解")]),t._v(" "),v("h2",{attrs:{id:"和-equals的对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#和-equals的对比"}},[t._v("#")]),t._v(" == 和 equals的对比")]),t._v(" "),v("p",[t._v("== 是一个比较运算符")]),t._v(" "),v("ol",[v("li",[t._v("==：既可以判断基本类型，又可以判断引用类型")]),t._v(" "),v("li",[t._v("==：如果判断基本类型，判断的是值是否相等。示例：int i = 10;double d = 10.0;")]),t._v(" "),v("li",[t._v("==: 如果判断引用类型，判断的是地址是否相等，及判断是不是同一个对象")]),t._v(" "),v("li",[t._v("equals：是Object类中的方法，只能判断引用类型")]),t._v(" "),v("li",[t._v("默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如：Integer，String")])]),t._v(" "),v("h2",{attrs:{id:"hashcode方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashcode方法"}},[t._v("#")]),t._v(" hashCode方法")]),t._v(" "),v("ol",[v("li",[t._v("提高具有哈希结构的容器的效率；")]),t._v(" "),v("li",[t._v("两个引用，如果指向的是同一个对象，则哈希值是一样的")]),t._v(" "),v("li",[t._v("两个引用，如果指向的是不同对象，则哈希值是不一样的\n4.哈希值主要根据地址号来，不能完全将哈希值等价于地址")])]),t._v(" "),v("h2",{attrs:{id:"tostring"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[t._v("#")]),t._v(" toString")]),t._v(" "),v("p",[t._v("基本介绍：\n默认返回：全类名（包名+类名）+@+哈希值的十六进制\n重写toString方法，打印对象或拼接对象时都会自动调用对象的toString形式\n当直接输出一个对象时，toString方法会被默认的调用")]),t._v(" "),v("h2",{attrs:{id:"finalize方法-开发中使用较少"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finalize方法-开发中使用较少"}},[t._v("#")]),t._v(" finalize方法（开发中使用较少）")]),t._v(" "),v("ol",[v("li",[t._v("当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法。\n做一些资源释放操作")]),t._v(" "),v("li",[t._v("什么时候回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾\n对象，就会使用垃圾回收机制来销毁该对象，在销毁对象前，会先调用finalize方法")]),t._v(" "),v("li",[t._v("垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()\n主动除法垃圾回收机制")])]),t._v(" "),v("h1",{attrs:{id:"面向对象高级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象高级"}},[t._v("#")]),t._v(" 面向对象高级")]),t._v(" "),v("h2",{attrs:{id:"类变量和类方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类变量和类方法"}},[t._v("#")]),t._v(" 类变量和类方法")]),t._v(" "),v("h3",{attrs:{id:"什么是类变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是类变量"}},[t._v("#")]),t._v(" 什么是类变量")]),t._v(" "),v("p",[t._v("类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类\n的对象去访问（修改）它时，取到（修改）的都是相同的值。")]),t._v(" "),v("h3",{attrs:{id:"如何定义类变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何定义类变量"}},[t._v("#")]),t._v(" 如何定义类变量")]),t._v(" "),v("p",[t._v("定义语法： 访问修饰符 static 数据类型 变量名；【推荐】")]),t._v(" "),v("h3",{attrs:{id:"类变量的内存布局-跟jdk版本有关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类变量的内存布局-跟jdk版本有关"}},[t._v("#")]),t._v(" 类变量的内存布局（跟jdk版本有关）")]),t._v(" "),v("ol",[v("li",[t._v("static变量是同一个类所有对象共享")]),t._v(" "),v("li",[t._v("static类变量，在加载的时候就生成")])]),t._v(" "),v("h3",{attrs:{id:"类变量的使用注意事项和细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类变量的使用注意事项和细节"}},[t._v("#")]),t._v(" 类变量的使用注意事项和细节")]),t._v(" "),v("ol",[v("li",[t._v("什么时候需要类变量\n当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用\n类变量（静态变量）")]),t._v(" "),v("li",[t._v("类变量与实例变量（普通属性）区别\n类变量是该类的所有对象共享的，而实例变量的每个对象独享的")]),t._v(" "),v("li",[t._v("加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态方法")]),t._v(" "),v("li",[t._v("类变量可以通过 类名.类变量名（推荐） 或者 对象名.类变量名来访问")])]),t._v(" "),v("h3",{attrs:{id:"类方法基本介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类方法基本介绍"}},[t._v("#")]),t._v(" 类方法基本介绍")]),t._v(" "),v("p",[t._v("类方法也叫静态方法")]),t._v(" "),v("h3",{attrs:{id:"如何定义类变量-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何定义类变量-2"}},[t._v("#")]),t._v(" 如何定义类变量")]),t._v(" "),v("p",[t._v("定义语法： 访问修饰符 static 数据返回类型 方法名(){}【推荐】\n类方法可以通过 类名.类方法名（推荐） 或者 对象名.类方法名来访问")]),t._v(" "),v("h3",{attrs:{id:"类方法使用注意事项和细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类方法使用注意事项和细节"}},[t._v("#")]),t._v(" 类方法使用注意事项和细节")]),t._v(" "),v("ol",[v("li",[t._v("类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区\n类方法中无this的参数")]),t._v(" "),v("li",[t._v("类方法可以通过类名调用，也可以通过对象名调用")]),t._v(" "),v("li",[t._v("普通方法的对象有关，需要通过对象名调用")]),t._v(" "),v("li",[t._v("类方法中不与允许使用和对象有关的关键字，比如this和super")]),t._v(" "),v("li",[t._v("类方法（静态方法）中只能访问静态变量或静态方法")]),t._v(" "),v("li",[t._v("普通成员方法，即可访问普通方法（变量），也可以访问静态变量（方法）")])]),t._v(" "),v("h2",{attrs:{id:"main方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#main方法"}},[t._v("#")]),t._v(" main方法")]),t._v(" "),v("h2",{attrs:{id:"代码块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[t._v("#")]),t._v(" 代码块")]),t._v(" "),v("p",[t._v("基本介绍\n代码块又称为初始化块，属于类中的成员【既是类的一部分】，类似于方法，将逻辑语句\n封装在方法体中，通过{}包围起来。\n但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或\n类显示调用，而是加载类时，或创建对象时隐式调用")]),t._v(" "),v("p",[t._v("基本语法\n【修饰符】{\n代码\n};\n注意：")]),t._v(" "),v("ol",[v("li",[t._v("修饰符可选，要写的话只能写static")]),t._v(" "),v("li",[t._v("代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块")]),t._v(" "),v("li",[t._v("逻辑语句可以为任何逻辑语句\n4。 ;号可以写上也可以省略")])]),t._v(" "),v("p",[t._v("代码块使用注意事项和细节")]),t._v(" "),v("ol",[v("li",[t._v("static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行\n一次，如果是普通代码块，每创建一个对象，就执行")]),t._v(" "),v("li",[t._v("类什么时候被加载（重要）\n"),v("ul",[v("li",[t._v("创建对象实例时。（new）")]),t._v(" "),v("li",[t._v("创建子类对象实例，父类也会被加载")]),t._v(" "),v("li",[t._v("使用类的静态成员时（静态属性，静态方法）")])])]),t._v(" "),v("li",[t._v("普通代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。\n如果只是使用类的静态成员，普通的代码块并不会执行。")]),t._v(" "),v("li",[t._v("创建一个对象时，在一个类调用顺序是：（重点，难点）：\n"),v("ul",[v("li",[t._v("调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化\n调用优先级一样，如果多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）")]),t._v(" "),v("li",[t._v("调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化\n调用优先级一样，如果多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）\n*调用构造方法。")])])]),t._v(" "),v("li",[t._v("构造器的最前面其实是隐含了super（）和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，\n就执行完毕，因此优先于构造器和普通代码块执行。")]),t._v(" "),v("li",[t._v("创建一个子类对象时（继承关系），静态代码块，静态属性初始化，普通代码块，\n普通属性初始化，构造方法的调用顺序如下：\n"),v("ul",[v("li",[t._v("父类的静态代码块和静态属性（优先级一样，按定义顺序执行）")]),t._v(" "),v("li",[t._v("子类的静态代码块的静态属性（优先级一样，按定义顺序执行）")]),t._v(" "),v("li",[t._v("父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）")]),t._v(" "),v("li",[t._v("父类的构造方法")]),t._v(" "),v("li",[t._v("子类的构普通代码块和普通属性初始化（优先级一样，按定义顺序执行）")]),t._v(" "),v("li",[t._v("子类的构造方法 //面试题")])])]),t._v(" "),v("li",[t._v("静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。")])]),t._v(" "),v("h2",{attrs:{id:"单例模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" 单例模式")]),t._v(" "),v("p",[t._v("实现步骤：")]),t._v(" "),v("ol",[v("li",[t._v("构造器私有化")]),t._v(" "),v("li",[t._v("类的内部创建对象")]),t._v(" "),v("li",[t._v("向外暴露一个静态公共方法")])]),t._v(" "),v("p",[t._v("饿汉模式vs懒汉模式")]),t._v(" "),v("ol",[v("li",[t._v("二者最主要的区别在于创建对象的时机不同；饿汉式是在类加载就创建了对象实例\n而懒汉式是在使用时才创建")]),t._v(" "),v("li",[t._v("饿汉式不存在线程安全问题，懒汉式存在线程安全问题")]),t._v(" "),v("li",[t._v("饿汉式存在资源浪费的可能。\n4.在javaSE标准类中，java.lang.Runtime就是经典的单例模式")])]),t._v(" "),v("h2",{attrs:{id:"final关键字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#final关键字"}},[t._v("#")]),t._v(" final关键字")]),t._v(" "),v("p",[t._v("基本介绍\nfinal可以修饰类、属性、方法和局部变量\nfinal使用场景：")]),t._v(" "),v("ol",[v("li",[t._v("当不希望类被继承时，可以用final修饰")]),t._v(" "),v("li",[t._v("当不希望父类的某个方法被子类覆盖/重写时。可以用final关键字修饰")]),t._v(" "),v("li",[t._v("当不希望类的某个属性的值被修改，可以用final修饰")]),t._v(" "),v("li",[t._v("当不希望某个局部变量被修改，可以使用final修饰")])]),t._v(" "),v("p",[t._v("final使用注意事项和细节")]),t._v(" "),v("ol",[v("li",[t._v("final修饰的属性又叫常量，一般用XX_XX_XX来命名")]),t._v(" "),v("li",[t._v("final修饰的属性在定义时，必须赋初始值，并且以后不能再修改，赋值可以在\n如下位置之一\n"),v("ul",[v("li",[t._v("定义时")]),t._v(" "),v("li",[t._v("再构造器中")]),t._v(" "),v("li",[t._v("再代码块中")])])]),t._v(" "),v("li",[t._v("如果final修饰的属性是静态的，则初始化的位置只能是\n"),v("ul",[v("li",[t._v("定义时")]),t._v(" "),v("li",[t._v("再静态代码块 不能再构造器中赋值")])])]),t._v(" "),v("li",[t._v("final类不能继承，但是可以实例化对象")]),t._v(" "),v("li",[t._v("如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。")]),t._v(" "),v("li",[t._v("如果一个类已经是final类了，就没有必要再将方法修饰成final方法")]),t._v(" "),v("li",[t._v("final不能修饰构造方法")]),t._v(" "),v("li",[t._v("final和static搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理")]),t._v(" "),v("li",[t._v("包装类（Integer，Double，Float，Boolean等都是final），String也是final类")])]),t._v(" "),v("h2",{attrs:{id:"抽象类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),v("p",[t._v("抽象类的介绍")]),t._v(" "),v("ol",[v("li",[t._v("用abstract关键字来修饰一个类时，这个类就叫抽象类 访问修饰符 abstract 类名{}")]),t._v(" "),v("li",[t._v("用abstract关键字来修饰一个方法时，这个方法就是抽象方法\n访问修饰符 abstract 返回类型 方法名 (参数列表);//没有方法体")]),t._v(" "),v("li",[t._v("抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类（）")]),t._v(" "),v("li",[t._v("抽象类，在框架和设计模式使用较多")])]),t._v(" "),v("p",[t._v("抽象类使用的注意事项和细节")]),t._v(" "),v("ol",[v("li",[t._v("抽象类不能被实例化")]),t._v(" "),v("li",[t._v("抽象类不一定包含abstract方法")]),t._v(" "),v("li",[t._v("一旦类包含了abstract方法，则这个类必须声明为abstract")]),t._v(" "),v("li",[t._v("abstract只能修饰类的方法，不能修饰属性和其他的\n5.抽象类可以又任意成员[抽象类本质还是类]")]),t._v(" "),v("li",[t._v("抽象方法不能有主体，既不能实现")]),t._v(" "),v("li",[t._v("如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也\n声明为abstract类")]),t._v(" "),v("li",[t._v("抽象方法不能使用private、final和static来修饰，因为这些关键字都i是和重写相违背")])]),t._v(" "),v("p",[t._v('抽象类最佳实践-模板设计模式\nabstract class Template{//抽象类\npublic abstract void job();//抽象方法\npublic void caleTimes(){//统计耗时多久\n//统计当前时间距离 1970-1-1 0:0:0 的时间差，单位ms\nlong start = System.currentTimeMillis();\njob();//java动态绑定机制\nlong end = System.currentTimeMillis();\nSystem.out.println("耗时：" + (end - start));\n}')]),t._v(" "),v("p",[t._v("}")]),t._v(" "),v("h2",{attrs:{id:"接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),v("p",[t._v("基本介绍\n接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据集体情况\n把这个方法实现\n语法：\ninterface 接口名{\n//属性\n//方法(1.抽象方法 2.默认实现方法(default) 3.静态方法)\n}")]),t._v(" "),v("p",[t._v("class 类名 implements 接口{\n自己属性；\n自己方法：\n必须实现的接口的抽象方法\n}")]),t._v(" "),v("p",[t._v("接口的注意事项和使用细节")]),t._v(" "),v("ol",[v("li",[t._v("接口不能被实例化")]),t._v(" "),v("li",[t._v("接口中所有方法是public方法，接口中抽象方法，可以不用abstract修饰")]),t._v(" "),v("li",[t._v("一个普通类实现接口，就必须将该接口的所有方法都实现")]),t._v(" "),v("li",[t._v("抽象类实现接口，可以不用实现接口的方法")]),t._v(" "),v("li",[t._v("一个类同时可以实现多个接口")]),t._v(" "),v("li",[t._v("接口中的属性只能是final的，而且是public static final修饰符")]),t._v(" "),v("li",[t._v("接口中属性的访问形式：接口名.属性名")]),t._v(" "),v("li",[t._v("一个接口不能继承其他的类，但是可以继承多个别的接口")]),t._v(" "),v("li",[t._v("接口的修饰符只能是public和默认")])]),t._v(" "),v("p",[t._v("实现接口vs继承类")]),t._v(" "),v("ul",[v("li",[t._v("接口和继承解决的问题不同\n继承的价值主要在于：解决代码的复用性和可维护性\n接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法")]),t._v(" "),v("li",[t._v("接口比继承更加灵活\n接口比继承更加灵活，继承是满足is-a的关系，而接口只需要满足like-a的关系")]),t._v(" "),v("li",[t._v("接口在一个程度上实现代码解耦")])]),t._v(" "),v("p",[t._v("接口的多态特性")]),t._v(" "),v("ol",[v("li",[t._v("多态参数")]),t._v(" "),v("li",[t._v("多态数组")]),t._v(" "),v("li",[t._v("接口存在多态传递现象")])]),t._v(" "),v("h1",{attrs:{id:"内部类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[t._v("#")]),t._v(" 内部类")]),t._v(" "),v("h2",{attrs:{id:"局部内部类的使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#局部内部类的使用"}},[t._v("#")]),t._v(" 局部内部类的使用")]),t._v(" "),v("p",[t._v("说明：局部内部类定义在外部类的局部位置，比如方法中，并且有类名")]),t._v(" "),v("ol",[v("li",[t._v("可以直接访问外部类的所有成员，包含私有的")]),t._v(" "),v("li",[t._v("不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量不能使用\n修饰符。但是可以使用final修饰")]),t._v(" "),v("li",[t._v("作用域：仅仅在定义它的方法或代码块中")]),t._v(" "),v("li",[t._v("局部内部类--访问---\x3e外部类的成员【访问方式：直接访问】")]),t._v(" "),v("li",[t._v("外部类--访问---\x3e 局部内部类的成员【访问方式：创建对象访问，必须在作用域内】")]),t._v(" "),v("li",[t._v("外部其他类--不能访问---\x3e 局部内部类（因为局部内部类是一个局部变量）")]),t._v(" "),v("li",[t._v("如果外部类和局部内部类的成员重名，默认遵循就近原则，如果想访问外部类的\n成员，则可以使用（外部类名.this.成员）去访问")])]),t._v(" "),v("h2",{attrs:{id:"匿名内部类-重点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#匿名内部类-重点"}},[t._v("#")]),t._v(" 匿名内部类（重点）")]),t._v(" "),v("p",[t._v("说明：匿名内部类是定义在外部类的局部位置\n匿名内部类的使用\n1.匿名内部类的基本语法\nnew 类或接口(参数列表){\n类体\n};\n2. 匿名内部类既是一个类的定义、同时本身也是一个对象\n3. 可以直接访问外部类的所有成员，包含私有的\n4. 不能添加任意访问修饰符，因为它的地位就是一个局部变量\n5. 仅仅在定义它的方法或代码块中\n6. 匿名内部类--访问---\x3e外部类的成员【访问方式：直接访问】\n7. 外部其他类--不能访问---\x3e 匿名内部类（因为它的地位就是一个局部变量）\n8. 如果外部类和内部类的成员重名，默认遵循就近原则，如果想访问外部类的\n成员，则可以使用（外部类名.成员）去访问")]),t._v(" "),v("h2",{attrs:{id:"成员内部类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#成员内部类"}},[t._v("#")]),t._v(" 成员内部类")]),t._v(" "),v("p",[t._v("成员内部类的使用\n说明：成员内部类是定义在外部类的成员位置，并且没有static修饰")]),t._v(" "),v("ol",[v("li",[t._v("可以直接访问外部类的所有成员，包含私有的")]),t._v(" "),v("li",[t._v("可以添加任意访问修饰符（public、protected、默认、private）")]),t._v(" "),v("li",[t._v("作用域：和外部类的其他成员一样，为整个类体")]),t._v(" "),v("li",[t._v("成员内部类--访问---\x3e外部类的成员【访问方式：直接访问】")]),t._v(" "),v("li",[t._v("外部类--访问---\x3e 内部类【访问方式：创建对象访问】")]),t._v(" "),v("li",[t._v("外部其他类--访问---\x3e 成员内部类")]),t._v(" "),v("li",[t._v("如果外部类和内部类的成员重名，默认遵循就近原则，如果想访问外部类的\n成员，则可以使用（外部类名.this.成员）去访问")])]),t._v(" "),v("h2",{attrs:{id:"静态内部类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态内部类"}},[t._v("#")]),t._v(" 静态内部类")]),t._v(" "),v("p",[t._v("静态内部类的使用\n说明：静态内部类是定义在外部类的成员位置，并且有static修饰")]),t._v(" "),v("ol",[v("li",[t._v("可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员")]),t._v(" "),v("li",[t._v("可以添加任意访问修饰符（public、protected、默认、private）")]),t._v(" "),v("li",[t._v("作用域：和其他成员一样，为整个类体")]),t._v(" "),v("li",[t._v("静态内部类--访问---\x3e外部类【访问方式：直接访问】")]),t._v(" "),v("li",[t._v("外部类--访问---\x3e 静态内部类【访问方式：创建对象访问】")]),t._v(" "),v("li",[t._v("外部其他类--访问---\x3e 静态内部类（通过类名直接访问或编写一个方法，返回静态内部类的对象实例）")]),t._v(" "),v("li",[t._v("如果外部类和静态内部类的成员重名，默认遵循就近原则，如果想访问外部类的\n成员，则可以使用（外部类名.成员）去访问")])]),t._v(" "),v("h1",{attrs:{id:"自定义类实现枚举"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义类实现枚举"}},[t._v("#")]),t._v(" 自定义类实现枚举")]),t._v(" "),v("ol",[v("li",[t._v("构造器私有话")]),t._v(" "),v("li",[t._v("本类内部创建一组对象")]),t._v(" "),v("li",[t._v("对外暴露对象（通过为对象添加public final static修饰符）")]),t._v(" "),v("li",[t._v("可以提供get方法，但是不要提供set")])]),t._v(" "),v("h1",{attrs:{id:"异常"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[t._v("#")]),t._v(" 异常")]),t._v(" "),v("h2",{attrs:{id:"try-catch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#try-catch"}},[t._v("#")]),t._v(" try-catch")]),t._v(" "),v("p",[t._v("try-catch-finally执行顺序小结")]),t._v(" "),v("ol",[v("li",[t._v("如果没有出现异常。则执行try块中所有语句，不执行catch块中语句，如果\n有finally，最后还需要执行finally里面的语句")]),t._v(" "),v("li",[t._v("如果出现异常，则try块中异常发生后，try块剩下的语句不再执行，将执行\ncatch块中的语句，如果finally，最后还需要执行finally里面的语句")])]),t._v(" "),v("h2",{attrs:{id:"throw异常处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#throw异常处理"}},[t._v("#")]),t._v(" throw异常处理")]),t._v(" "),v("p",[t._v("注意事项和使用细节")]),t._v(" "),v("ol",[v("li",[t._v("对于编译异常，程序中必须处理")]),t._v(" "),v("li",[t._v("对于运行时异常，程序中如果没有处理，默认就是throws的方式处理")]),t._v(" "),v("li",[t._v("子类重写父类时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和\n父类抛出的异常一致，要么为父类抛出的异常类型的子类型")]),t._v(" "),v("li",[t._v("再throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws")])]),t._v(" "),v("h1",{attrs:{id:"包装类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#包装类"}},[t._v("#")]),t._v(" 包装类")]),t._v(" "),v("p",[t._v("##包装类的分类")]),t._v(" "),v("ol",[v("li",[t._v("针对八种基本数据类型相应的引用类型--包装类\n2.有了类的特点，就可以调用类中的方法")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("基本数据类型")]),t._v(" "),v("th",[t._v("包装类")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("boolean")]),t._v(" "),v("td",[t._v("Boolean")])]),t._v(" "),v("tr",[v("td",[t._v("char")]),t._v(" "),v("td",[t._v("Character")])]),t._v(" "),v("tr",[v("td",[t._v("byte")]),t._v(" "),v("td",[t._v("Byte")])]),t._v(" "),v("tr",[v("td",[t._v("short")]),t._v(" "),v("td",[t._v("Short")])]),t._v(" "),v("tr",[v("td",[t._v("int")]),t._v(" "),v("td",[t._v("Integer")])]),t._v(" "),v("tr",[v("td",[t._v("long")]),t._v(" "),v("td",[t._v("Long")])]),t._v(" "),v("tr",[v("td",[t._v("float")]),t._v(" "),v("td",[t._v("Float")])]),t._v(" "),v("tr",[v("td",[t._v("double")]),t._v(" "),v("td",[t._v("Double")])])])]),t._v(" "),v("p",[t._v("包装类和基本数据的转换")]),t._v(" "),v("ol",[v("li",[t._v("jdk5前的手动装箱和拆箱方式，装箱：基本类型->包装类型，反之，拆箱")]),t._v(" "),v("li",[t._v("jdk5以后(含jdk5)的自动装箱和拆箱方式")]),t._v(" "),v("li",[t._v("自动装箱底层调用的是valueOf方法，比如Integer.valueOf()\n自动拆箱底层调用的是intValue方法。")])]),t._v(" "),v("blockquote",[v("p",[t._v("包装类测试题目")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("Object obj1 = true?new Integer(1):new Double(2.0);//三元运算符是一个整体\nSystem.out.println(obj1);//输出1.0\n")])])]),v("p",[t._v("包装类型和String类型的相互转换")]),t._v(" "),v("blockquote",[v("p",[t._v("包装类型——>String类型")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('Integer i =10;\n//方式1：\nString s1 = i.toString();\n//方式2：\nString s2 = String.alueOf(i);\n//方式3：\nString s3 = i + "";\n')])])]),v("blockquote",[v("p",[t._v("String -> 包装类")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("//方式1：\nInteger j =new Integer(s1);\n//方式2：\nInteger j2 = Integer.valueOf(s2)\n")])])]),v("blockquote",[v("p",[t._v("Inreger类题目")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("//示例1\nInteger i1 = new Integer(127);\nInteger i2 = new Integer(127);\nSystem.out.println(i1 == i2);//F\n//示例2\nInteger i3 = new Integer(128);\nInteger i4 = new Integer(128);\nSystem.out.println(i3 == i4);//F\n//示例3\nInteger i5 = 127;\nInteger i6 = 127;\nSystem.out.println(i5 == i6);//T\n//示例4\nInteger i7 = 128;\nInteger i8 = 128;\nSystem.out.println(i1 == i2);//F\n//示例5\nInteger i9 = 127;\nInteger i10 = new Integer(127);\nSystem.out.println(i9 == i10);//F\n//示例6\nInteger i11 = 127;\nint i12 = 127;\n//只要有基本数据类型，判断的是值是否相等\nSystem.out.println(i11 == i2);//T\n//示例7\nInteger i13 = 128;\nint i14 = 128;\nSystem.out.println(i13 == i4);//T\n\n")])])]),v("h2",{attrs:{id:"string类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#string类"}},[t._v("#")]),t._v(" String类")]),t._v(" "),v("p",[t._v("字符串特性")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('String a = "hello";;\nString b = "abc";\nString c = a+b;//创建了几个对象？内存图\n')])])]),v("p",[t._v('底层是StringBuilder sb = new StringBuilder();\nsb.append(a);sb.append(b);sb是在堆中，并且append是在原来的字符串的基础上追加\n重要规则：String c = "ab" + "cd";常量相加，看的是池。\nString c = a + b;变量相加，是在堆中')]),t._v(" "),v("blockquote",[v("p",[t._v("String常用方法")])]),t._v(" "),v("p",[t._v("toUpperCase()\nconcat()\nreplace()\nsplit()\ntoCharArray()\ncompareTo()")]),t._v(" "),v("p",[t._v("StringBuffer类")]),t._v(" "),v("blockquote",[v("p",[t._v("StringBuffer类常见方法")])]),t._v(" "),v("ol",[v("li",[t._v("增 append")]),t._v(" "),v("li",[t._v("删 delete")]),t._v(" "),v("li",[t._v("改 replace（start，end，string）//将start---end间的内容替换掉，不含end")]),t._v(" "),v("li",[t._v("查indexOf // 查找子串在字符串第一次出现的索引，如果找不到返回-1")]),t._v(" "),v("li",[t._v("插 insert")]),t._v(" "),v("li",[t._v("获取长度length")])]),t._v(" "),v("blockquote",[v("p",[t._v("StringBuilder类基本介绍")])]),t._v(" "),v("ol",[v("li",[t._v("一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步。该类\n被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。\n如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快")]),t._v(" "),v("li",[t._v("在StringBuilder上的主要操作是append和insert方法，可重载这些方法仪接收\n任意类型的数据")])]),t._v(" "),v("blockquote",[v("p",[t._v("String、StringBuffer 和 StringBuilder的选择")])]),t._v(" "),v("p",[t._v("使用的原则，结论：")]),t._v(" "),v("ol",[v("li",[t._v("如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder")]),t._v(" "),v("li",[t._v("如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder")]),t._v(" "),v("li",[t._v("如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer")]),t._v(" "),v("li",[t._v("如果字符串很少修改，被多个对象引用，使用String，比如配置信息")])]),t._v(" "),v("h2",{attrs:{id:"math类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#math类"}},[t._v("#")]),t._v(" Math类")]),t._v(" "),v("blockquote",[v("p",[t._v("Math类常见方法")])]),t._v(" "),v("ol",[v("li",[t._v("abs 绝对值")]),t._v(" "),v("li",[t._v("pow 求幂")]),t._v(" "),v("li",[t._v("ceil 向上取整")]),t._v(" "),v("li",[t._v("floor 向下取整")]),t._v(" "),v("li",[t._v("round 四舍五入")]),t._v(" "),v("li",[t._v("sqrt 求开方")]),t._v(" "),v("li",[t._v("random 求随机数")]),t._v(" "),v("li",[t._v("max 求两个数的最大值")]),t._v(" "),v("li",[t._v("min 求两个数的最小值")])]),t._v(" "),v("h2",{attrs:{id:"arrays类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arrays类"}},[t._v("#")]),t._v(" Arrays类")]),t._v(" "),v("blockquote",[v("p",[t._v("Arrays里面包含了一系列静态方法，用于管理或操作数组")])]),t._v(" "),v("ol",[v("li",[t._v("toString返回数组的字符串形式")]),t._v(" "),v("li",[t._v("sort排序(自然排序和定制排序)")]),t._v(" "),v("li",[t._v("binarySearch通过二分搜索法进行查找，要求必须排好序")])]),t._v(" "),v("h2",{attrs:{id:"system类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#system类"}},[t._v("#")]),t._v(" System类")]),t._v(" "),v("blockquote",[v("p",[t._v("System类常见方法和案例")])]),t._v(" "),v("ol",[v("li",[t._v("exit退出当前程序")]),t._v(" "),v("li",[t._v("arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组")]),t._v(" "),v("li",[t._v("currentTimeMillens:返回当前时间距离1970-1-1的毫秒数")]),t._v(" "),v("li",[t._v("gc:运行垃圾回收机制 System.gc();")])]),t._v(" "),v("h2",{attrs:{id:"大数据处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#大数据处理"}},[t._v("#")]),t._v(" 大数据处理")]),t._v(" "),v("p",[t._v("BigInteger和BigDecimal")]),t._v(" "),v("blockquote",[v("p",[t._v("常用方法\n1.add家\n2.subtract减\n3.multiply乘\n4.divide除(除法需要通过BigDecimal.ROUND_CEILING指定精度)\n应用场景：")])]),t._v(" "),v("ol",[v("li",[t._v("BigInteger适合保存比较大的整型")]),t._v(" "),v("li",[t._v("BigDecimal适合保存精度更高的浮点型（小数）")])]),t._v(" "),v("h2",{attrs:{id:"日期类-了解即可"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#日期类-了解即可"}},[t._v("#")]),t._v(" 日期类（了解即可）")]),t._v(" "),v("blockquote",[v("p",[t._v("第一代日期类")])]),t._v(" "),v("ol",[v("li",[t._v("Date:精确到毫秒，代表特定的瞬间")]),t._v(" "),v("li",[t._v("SimpleDateFormat：格式和解析日期的类\nSimpleDateFormat格式化和解析日期的具体类。它允许进行\n格式化（日期->文本）、解析（文本->日期）和规范化")])]),t._v(" "),v("blockquote",[v("p",[t._v("第二代日期类")])]),t._v(" "),v("ol",[v("li",[t._v("第二代日期类，主要是Calender类(日历)")]),t._v(" "),v("li",[t._v("Calender类是一个抽象类，它为特定瞬间与诸如Year、MONTH等日历字段\n提供一些方法，并为操作日历字段提供一些方法")])]),t._v(" "),v("blockquote",[v("p",[t._v("第三代日期类")])]),t._v(" "),v("p",[t._v("前面两代日期类的不足分析\nJDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入\nCalendar类之后被弃用了，而Calendar也存在问题是\n*可变性：像日期和时间这样的类应该是不可变的")]),t._v(" "),v("ul",[v("li",[t._v("偏移性：Date中的年份是从1990开始的，而月份都从0开始")]),t._v(" "),v("li",[t._v("格式化：格式化只对Date有用，Calendar则不行")]),t._v(" "),v("li",[t._v("此外，它们也不是线程安全的；不能处理闰秒等（每隔两天，多出1秒）")])]),t._v(" "),v("ol",[v("li",[t._v("LocalDate(日期/年月日)、LocalTime（时间/时分秒）、LocalDateTime（日期时间/年月日时分秒）JDK8加入")]),t._v(" "),v("li",[t._v("DateTimeFormatter格式化日期类"),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("DateTimeFormat dtf = DateTimeFormatter.ofPattern(格式)\nString str = dtf.format(日期对象);\n")])])])]),t._v(" "),v("li",[t._v("Instant 时间戳\n类似于Date\n提供了一系列和Date类转换的方式\n"),v("blockquote",[v("p",[t._v("Instant --\x3e Date")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("Date date = Date.from(instant);\n")])])]),v("blockquote",[v("p",[t._v("Date --\x3e Instant\nInstant instant = date.toInstant();")])])]),t._v(" "),v("li",[t._v("第三代日期类更多方法")])]),t._v(" "),v("ul",[v("li",[t._v("LocalDateTime类")]),t._v(" "),v("li",[t._v("MonthDay类：检查重复事件")]),t._v(" "),v("li",[t._v("是否是闰年")]),t._v(" "),v("li",[t._v("增加日期的某个部分")]),t._v(" "),v("li",[t._v("使用plus方法测试增加时间的某个部分")]),t._v(" "),v("li",[t._v("使用minus方法测试查看一年前和一年后的日期")])]),t._v(" "),v("h2",{attrs:{id:"set接口实现类-hashset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set接口实现类-hashset"}},[t._v("#")]),t._v(" Set接口实现类-HashSet")]),t._v(" "),v("p",[t._v("HashSet底层机制说明")]),t._v(" "),v("ol",[v("li",[t._v("Hash底层是HsahMap")]),t._v(" "),v("li",[t._v("添加一个元素时，先得到hash值-会转成索引")]),t._v(" "),v("li",[t._v("找到存储数据表table，看这个索引位置是否已经存放元素")]),t._v(" "),v("li",[t._v("如果没有直接加入")]),t._v(" "),v("li",[t._v("如果有，调用equals比较，如果相同，就放弃添加，如果不同，则添加到最后")]),t._v(" "),v("li",[t._v("再java")])]),t._v(" "),v("h1",{attrs:{id:"集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[t._v("#")]),t._v(" 集合")]),t._v(" "),v("p",[t._v("集合的框架体系图")]),t._v(" "),v("h2",{attrs:{id:"collection接口和常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#collection接口和常用方法"}},[t._v("#")]),t._v(" Collection接口和常用方法")]),t._v(" "),v("ul",[v("li",[t._v("Collection接口遍历元素方式1-使用Iterator（迭代器）")])]),t._v(" "),v("ol",[v("li",[t._v("Iterator对象称为迭代器，主要用于遍历Collection集合中的元素")]),t._v(" "),v("li",[t._v("所有实现了Collection接口的集合类都有一个Iterator()方法，用以返回\n一个实现了Iterator接口的对象，即可返回一个迭代器")]),t._v(" "),v("li",[t._v("Iterator的结构")]),t._v(" "),v("li",[t._v("Iterator仅用于遍历集合，Iterator本身并不存放对象")])]),t._v(" "),v("blockquote",[v("p",[t._v("迭代器的执行原理")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("Iterator iterator = coll.iterator();//得到一个集合的迭代器\nwhile (iterator.hasNext()) {//判断是否还有下一个元素\n     Object next = iterator.next(); //next()作用和：1.下移 2.将下移以后集合位置上的元素返回          \n}\n")])])]),v("ul",[v("li",[t._v("Collection接口遍历元素方式2-for循环增强\n增强for循环，可以替代iterator迭代器，特点：增强for就是简化版的iterator，\n本质是一样。只能用于遍历集合或数组")])]),t._v(" "),v("blockquote",[v("p",[t._v("基本语法")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("for(元素类型 元素名 ： 集合名或数组名){\n    访问元素\n}\n")])])]),v("h2",{attrs:{id:"list接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list接口"}},[t._v("#")]),t._v(" List接口")]),t._v(" "),v("h2",{attrs:{id:"arraylist底层结构和源码分析-重点-难点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arraylist底层结构和源码分析-重点-难点"}},[t._v("#")]),t._v(" ArrayList底层结构和源码分析（重点，难点）")]),t._v(" "),v("ol",[v("li",[t._v("ArrayList中维护了一个Object类型的数组elementData。\ntransient Object[] elementData；//transient 表示瞬间，短暂的，表示该属性不会被序列化")]),t._v(" "),v("li",[t._v("当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容\nelementData为10，如需要再次扩容，则扩容elementData为1.5倍")]),t._v(" "),v("li",[t._v("如果使用的是指定大小的构造器，则初始化elementData容量为指定大小，如果需要扩容，则直接扩容\nelementData为1.5倍。")])]),t._v(" "),v("h2",{attrs:{id:"vector底层结构和源码分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vector底层结构和源码分析"}},[t._v("#")]),t._v(" Vector底层结构和源码分析")]),t._v(" "),v("ol",[v("li",[t._v("Vector类的定义说明")]),t._v(" "),v("li",[t._v("Vector底层也是一个对象数组，protected Object[] elementData;")]),t._v(" "),v("li",[t._v("Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized")]),t._v(" "),v("li",[t._v("在开发中，需要线程同步安全时，考虑使用Vector")])]),t._v(" "),v("blockquote",[v("p",[t._v("Vector和ArrayList的比较")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("底层结构")]),t._v(" "),v("th",[t._v("版本")]),t._v(" "),v("th",[t._v("线程安通（同步）效率")]),t._v(" "),v("th",[t._v("扩容倍速")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("ArrayList")]),t._v(" "),v("td",[t._v("可变数组")]),t._v(" "),v("td",[t._v("jdk1.2")]),t._v(" "),v("td",[t._v("不安全，效率高")]),t._v(" "),v("td",[t._v("如果有参构造1.5倍 如果是无参 1.第一次10 2.从第二次开始1.5倍扩容")])]),t._v(" "),v("tr",[v("td",[t._v("Vector")]),t._v(" "),v("td",[t._v("可变数组 Object[]")]),t._v(" "),v("td",[t._v("jdk1.0")]),t._v(" "),v("td",[t._v("安全，效率不高")]),t._v(" "),v("td",[t._v("如果是无参，默认10，满后就2倍扩容 如果指定大小，则每次直接按照2倍扩容")])])])]),t._v(" "),v("h2",{attrs:{id:"linkedlist的底层结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist的底层结构"}},[t._v("#")]),t._v(" LinkedList的底层结构")]),t._v(" "),v("ol",[v("li",[t._v("LinkedList底层维护了一个双向链表")]),t._v(" "),v("li",[t._v("LinkedList中维护了两个属性first和last分别指向首节点和尾节点")]),t._v(" "),v("li",[t._v("每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过\nprev指向前一个，通过next指向后一个节点，最终实现双向链表")]),t._v(" "),v("li",[t._v("所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高")])]),t._v(" "),v("h2",{attrs:{id:"arraylist和linkedlist的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arraylist和linkedlist的比较"}},[t._v("#")]),t._v(" ArrayList和LinkedList的比较")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("底层结构")]),t._v(" "),v("th",[t._v("增删的效率")]),t._v(" "),v("th",[t._v("改查的效率")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("ArrayList")]),t._v(" "),v("td",[t._v("可变数组")]),t._v(" "),v("td",[t._v("较低 数组扩容")]),t._v(" "),v("td",[t._v("较高")])]),t._v(" "),v("tr",[v("td",[t._v("LinkedList")]),t._v(" "),v("td",[t._v("双向链表")]),t._v(" "),v("td",[t._v("较高，通过链表追加")]),t._v(" "),v("td",[t._v("较低")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("如何选择ArrayList和LinkedList：")])]),t._v(" "),v("ol",[v("li",[t._v("改查的操作多，选择ArrayList")]),t._v(" "),v("li",[t._v("增删的操作多，选择LinkedList")]),t._v(" "),v("li",[t._v("一般来说在程序中，80%~90%都是查询，因此大部分情况下回选择ArrayList")])]),t._v(" "),v("h2",{attrs:{id:"set接口基本介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set接口基本介绍"}},[t._v("#")]),t._v(" Set接口基本介绍")]),t._v(" "),v("ol",[v("li",[t._v("无序（添加和取出的顺序不一致），没有索引")]),t._v(" "),v("li",[t._v("不允许重复元素，所以最多包含一个null")]),t._v(" "),v("li",[t._v("JDK ADI中Set接口实现类： HashSet、TreeSet")])]),t._v(" "),v("h3",{attrs:{id:"set接口实现类-hashset-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set接口实现类-hashset-2"}},[t._v("#")]),t._v(" Set接口实现类-HashSet")]),t._v(" "),v("ol",[v("li",[t._v("HashSet实现了Set接口")]),t._v(" "),v("li",[t._v("HashSet实际上是HashMao")]),t._v(" "),v("li",[t._v("可以存放null值，但是只能又一个null")]),t._v(" "),v("li",[t._v("HashSet不保证元素是有序的，取决于hash后，在确定索引的结果")]),t._v(" "),v("li",[t._v("不能有重复元素/对象")])]),t._v(" "),v("h3",{attrs:{id:"set接口实现类-linkedhashset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set接口实现类-linkedhashset"}},[t._v("#")]),t._v(" Set接口实现类-LinkedHashSet")]),t._v(" "),v("ol",[v("li",[t._v("LinkedHashSet是HashSet的子类")]),t._v(" "),v("li",[t._v("LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表")]),t._v(" "),v("li",[t._v("LinkedHashSet根据元素的hashCode值来决定元素的存储位置同时使用链表\n维护元素的次序，使得元素看起来是以插入顺序保存")]),t._v(" "),v("li",[t._v("LinkedHashSet不允许添加重复元素")])]),t._v(" "),v("h2",{attrs:{id:"map接口和常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map接口和常用方法"}},[t._v("#")]),t._v(" Map接口和常用方法")]),t._v(" "),v("blockquote",[v("p",[t._v("Map接口实现类的特点")])]),t._v(" "),v("ol",[v("li",[t._v("Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value")]),t._v(" "),v("li",[t._v("Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中")]),t._v(" "),v("li",[t._v("Map中的key不允许重复")]),t._v(" "),v("li",[t._v("Map中的value可以重复")]),t._v(" "),v("li",[t._v("Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null可以多个")]),t._v(" "),v("li",[t._v("常用String类作为Map中的key")]),t._v(" "),v("li",[t._v("key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value")]),t._v(" "),v("li",[t._v("Map存放数据的key-value")])]),t._v(" "),v("blockquote",[v("p",[t._v("Map接口常用方法")])]),t._v(" "),v("ol",[v("li",[t._v("put:添加")]),t._v(" "),v("li",[t._v("remove：根据键删除映射关系")]),t._v(" "),v("li",[t._v("get：根据键获取值")]),t._v(" "),v("li",[t._v("size：获取元素个数")]),t._v(" "),v("li",[t._v("isEmpty：判断个数是否为0")]),t._v(" "),v("li",[t._v("clear：清楚")]),t._v(" "),v("li",[t._v("containsKey：查找键是否存在")])]),t._v(" "),v("h2",{attrs:{id:"map六大遍历方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map六大遍历方式"}},[t._v("#")]),t._v(" Map六大遍历方式")]),t._v(" "),v("h2",{attrs:{id:"hashtable"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[t._v("#")]),t._v(" HashTable")]),t._v(" "),v("ol",[v("li",[t._v("存放的元素是键值对")]),t._v(" "),v("li",[t._v("HashTable的键和值都不能为null")]),t._v(" "),v("li",[t._v("HashTable使用方法和HashMap一样")]),t._v(" "),v("li",[t._v("HashTable是线程安全的（synchronized），HashMap是线程不安全的")])]),t._v(" "),v("h2",{attrs:{id:"map接口实现类-properties"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map接口实现类-properties"}},[t._v("#")]),t._v(" Map接口实现类-Properties")]),t._v(" "),v("ol",[v("li",[t._v("Properties类继承自HashTable类并且实现了Map接口，也是使用一种键值对的形式来保存数据")]),t._v(" "),v("li",[t._v("使用特点和HashTable类似")]),t._v(" "),v("li",[t._v("Properties可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改")])]),t._v(" "),v("blockquote",[v("p",[t._v("开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性\n进行选择，分析如下：")])]),t._v(" "),v("ol",[v("li",[t._v("先判断存储的类型（一组对象[单例]或一组键值对[双例]）")]),t._v(" "),v("li",[t._v("一组对象[单例]：Collection接口\n允许重复：List\n增删多：LinkedList [底层维护一个双向链表]\n改查多：ArrayList[底层维护Object类型的可变数组]\n不允许重复：Set\n无序：HashSet[底层是HashMap，维护了一个哈希表即数组+链表+红黑树]\n排序:TreeSet\n插入和取出顺序一致：LinkedHashSet，维护数组+双向链表")]),t._v(" "),v("li",[t._v("一组键值对双例：Map\n键无序：HashMap [底层是：哈希表 jdk7：数组+链表 jdk8：数组+链表+红黑树]\n键排序：TreeMap\n键插入和取出顺序一致：LinkedHashMap\n读出文件 Properties")])]),t._v(" "),v("h2",{attrs:{id:"collections工具类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#collections工具类"}},[t._v("#")]),t._v(" Collections工具类")]),t._v(" "),v("blockquote",[v("p",[t._v("Collections工具类介绍")])]),t._v(" "),v("ol",[v("li",[t._v("Collections是一个操作Set、List和Map等集合的工具类")]),t._v(" "),v("li",[t._v("Collections中提供了一系列静态方法对集合元素进行排序、查询和修改等操作")])]),t._v(" "),v("p",[t._v("排序操作：")]),t._v(" "),v("ol",[v("li",[t._v("reverse(List)：反转List中元素的顺序")]),t._v(" "),v("li",[t._v("shuffle(List)：对List集合元素进行随机排序")]),t._v(" "),v("li",[t._v("sort(List)：根据元素的自然顺序对指定List集合按升序排序")]),t._v(" "),v("li",[t._v("sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序")]),t._v(" "),v("li",[t._v("swap(List,int,int)：将指定list集合中的i处元素个j处元素进行交换")])]),t._v(" "),v("p",[t._v("查找、替换")]),t._v(" "),v("ol",[v("li",[t._v("Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素")]),t._v(" "),v("li",[t._v("Object max(Collection,Comparator)根据Comparator指定的顺序，返回给定集合中的最大元素")]),t._v(" "),v("li",[t._v("Object min(Collection)")]),t._v(" "),v("li",[t._v("Object min(Collection,Comparator)")]),t._v(" "),v("li",[t._v("int frequency(Collection,Object)：返回指定集合中指定元素的出现次数")]),t._v(" "),v("li",[t._v("void copy(List dest,List src)将src中的内容复制到dest中")]),t._v(" "),v("li",[t._v("boolean replaceAll(List list,Object oldVal,Object newVal)使用新值替换List对象的所有旧值")])]),t._v(" "),v("h1",{attrs:{id:"泛型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),v("p",[t._v("使用传统方法的问题分析")]),t._v(" "),v("ol",[v("li",[t._v("不能对加入到集合ArrayList中的数据类型进行约束（不安全）")]),t._v(" "),v("li",[t._v("遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响")])]),t._v(" "),v("blockquote",[v("p",[t._v("泛型的好处")])]),t._v(" "),v("ol",[v("li",[t._v("编译时，检查添加元素的类型，提高安全性")]),t._v(" "),v("li",[t._v("减少类型转换的次数，提高效率")]),t._v(" "),v("li",[t._v("不在提示编译警告")])]),t._v(" "),v("p",[t._v("泛型介绍")]),t._v(" "),v("ol",[v("li",[t._v("泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题")]),t._v(" "),v("li",[t._v("在类声明或实例化时只要指定好需要的具体的类型即可")]),t._v(" "),v("li",[t._v("java泛型可以保证如果程序存在编译时没有发出警告，运行时就不会产生ClassCastException异常。\n同时代码更加简洁、健壮")]),t._v(" "),v("li",[t._v("泛型的作用是：可以在类声明时通过一个标识表示类某个属性的类型，或者是某个方法的返回值的类型，\n或者是参数类型。")])]),t._v(" "),v("p",[t._v("泛型的语法")]),t._v(" "),v("blockquote",[v("p",[t._v("声明\ninterface 接口"),v("T",[t._v("{} 和 class类<K,V>{}\n说明：")])],1)]),t._v(" "),v("ol",[v("li",[t._v("其中，T,K,V不代表值，而是表示类型")]),t._v(" "),v("li",[t._v("任意字母都可以。常用T表示，是Type的缩写")])]),t._v(" "),v("blockquote",[v("p",[t._v("泛型的实例化：\n要在类名后面指定类型参数的值（类型）。如：")])]),t._v(" "),v("ol",[v("li",[t._v("List"),v("String",[t._v(" strList = new ArrayList"),v("String",[t._v("();")])],1)],1),t._v(" "),v("li",[t._v("Iterator"),v("Customer",[t._v(" iterator = customers.iterator();")])],1)]),t._v(" "),v("h2",{attrs:{id:"泛型使用的注意事项和细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型使用的注意事项和细节"}},[t._v("#")]),t._v(" 泛型使用的注意事项和细节")]),t._v(" "),v("ol",[v("li",[t._v("interface list"),v("T",[t._v("{},public class HashSet"),v("E",[t._v("{}...等等说明\nT，E只能是引用类型")])],1)],1)]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("List<int> list2 = new ArrayList<int>();//错误\n")])])]),v("ol",{attrs:{start:"2"}},[v("li",[t._v("在给泛型具体类型后，可以传入该类型或者其子类类型")]),t._v(" "),v("li",[t._v("List list2 = new ArrayList<>();//默认泛型是Object")])]),t._v(" "),v("h2",{attrs:{id:"自定义泛型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义泛型"}},[t._v("#")]),t._v(" 自定义泛型")]),t._v(" "),v("blockquote",[v("p",[t._v("基本语法\nclass 类名<T,R...>{\n成员\n}")])]),t._v(" "),v("blockquote",[v("p",[t._v("注意细节")])]),t._v(" "),v("ol",[v("li",[t._v("普通成员可以使用泛型(属性、方法)")]),t._v(" "),v("li",[t._v("使用泛型的数组，不能初始化")]),t._v(" "),v("li",[t._v("静态方法中不能使用类的泛型")]),t._v(" "),v("li",[t._v("泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）")]),t._v(" "),v("li",[t._v("如果再创建对象时，没有指定类型，默认为Object")])]),t._v(" "),v("h2",{attrs:{id:"自定义泛型接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义泛型接口"}},[t._v("#")]),t._v(" 自定义泛型接口")]),t._v(" "),v("blockquote",[v("p",[t._v("基本语法\ninterface 接口名<T,R...>{\n}")])]),t._v(" "),v("blockquote",[v("p",[t._v("注意细节")])]),t._v(" "),v("ol",[v("li",[t._v("接口中，静态成员也不能使用泛型")]),t._v(" "),v("li",[t._v("泛型接口的类型，在继承接口或者实现接口时确定")]),t._v(" "),v("li",[t._v("没有指定类型，默认为Object")])]),t._v(" "),v("h1",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),v("h2",{attrs:{id:"释放锁的分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#释放锁的分析"}},[t._v("#")]),t._v(" 释放锁的分析")]),t._v(" "),v("ol",[v("li",[t._v("当前线程的同步方法，同步代码执行借宿")]),t._v(" "),v("li",[t._v("当前线程在同步代码块、同步方法中遇到break、return")]),t._v(" "),v("li",[t._v("当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束")]),t._v(" "),v("li",[t._v("当前线程在同步代码块、同步方法中执行了线程对象的wait（）方法。当前线程暂停，并释放锁")])]),t._v(" "),v("blockquote",[v("p",[t._v("以下操作不会释放锁")])]),t._v(" "),v("ol",[v("li",[t._v("线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法\n暂停当前线程的执行、不会释放锁")]),t._v(" "),v("li",[t._v("线程执行同步代码时，其他线程调用了该线程的suspend（）方法将该线程挂起，该线程不会释放锁")])]),t._v(" "),v("h1",{attrs:{id:"线程相关概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程相关概念"}},[t._v("#")]),t._v(" 线程相关概念")]),t._v(" "),v("ol",[v("li",[t._v("单线程：同一时刻，只允许执行一个线程")]),t._v(" "),v("li",[t._v("多线程：同一时刻，可以执行多个线程")]),t._v(" "),v("li",[t._v("并发：同一个时刻，多个任务交替执行，单核cpu实现的多个任务就是并发")]),t._v(" "),v("li",[t._v("并行：同一个时刻，多个任务同时执行。多核cpu可以实现并行。")])]),t._v(" "),v("h2",{attrs:{id:"常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[t._v("#")]),t._v(" 常用方法")]),t._v(" "),v("ol",[v("li",[t._v("setName //设置线程名称，使之与参数那么相同")]),t._v(" "),v("li",[t._v("getName //返回线程的，名称")]),t._v(" "),v("li",[t._v("start //使该线程开始执行；java虚拟机底层调用该线程的start0方法")]),t._v(" "),v("li",[t._v("run //调用线程对象run方法")]),t._v(" "),v("li",[t._v("setPriority //更改线程优先级")]),t._v(" "),v("li",[t._v("getPriority //获取线程的优先级")]),t._v(" "),v("li",[t._v("sleep //在指定的毫秒内让当前正在执行的线程休眠（暂停执行）")]),t._v(" "),v("li",[t._v("interrupt //中断线程")]),t._v(" "),v("li",[t._v("setDaemon //设置守护线程")])]),t._v(" "),v("h2",{attrs:{id:"常用方法2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用方法2"}},[t._v("#")]),t._v(" 常用方法2")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("yield:线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，\n所以也不一定礼让成功")])]),t._v(" "),v("li",[v("p",[t._v("join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程\n所有的任务")])])]),t._v(" "),v("h2",{attrs:{id:"用户线程和守护线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户线程和守护线程"}},[t._v("#")]),t._v(" 用户线程和守护线程")]),t._v(" "),v("ol",[v("li",[t._v("用户线程：也叫工作线程，当线程的任务执行完或通知方法结束")]),t._v(" "),v("li",[t._v("守护线程：一般是为工作线程服务的，当所有用户线程结束，守护线程自动结束（eg:垃圾回收机制）")])]),t._v(" "),v("h2",{attrs:{id:"线程7大状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程7大状态"}},[t._v("#")]),t._v(" 线程7大状态")]),t._v(" "),v("h2",{attrs:{id:"线程同步机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程同步机制"}},[t._v("#")]),t._v(" 线程同步机制")]),t._v(" "),v("p",[t._v("同步具体方法-Synchronized")]),t._v(" "),v("ol",[v("li",[t._v("同步代码块\nsynchronized(对象){ //得到对象的锁，才能操作同步代码\n//需要被同步代码；\n}")]),t._v(" "),v("li",[t._v("synchronized还可以放在方法声明中，表示整个方法-为同步方法")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v(" public synchronized void m(String name){\n        //需要被同步的代码\n }\n")])])]),v("h2",{attrs:{id:"互斥锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[t._v("#")]),t._v(" 互斥锁")]),t._v(" "),v("blockquote",[v("p",[t._v("二进制文件\n声音，视频，word文档，pdf")])]),t._v(" "),v("h2",{attrs:{id:"节点流和处理流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#节点流和处理流"}},[t._v("#")]),t._v(" 节点流和处理流")]),t._v(" "),v("p",[t._v("对象流 ObjectInputStream和ObjectOutputStream")]),t._v(" "),v("blockquote",[v("p",[t._v("序列化和反序列化")])]),t._v(" "),v("ol",[v("li",[t._v("序列化就是在保存数据时，保存数据的值和数据类型")]),t._v(" "),v("li",[t._v("反序列化就是在恢复数据时，恢复数据的值和数据类型")]),t._v(" "),v("li",[t._v("需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该\n类必须实现如下两个接口之一：\n"),v("ul",[v("li",[t._v("Serializable //这是一个标记接口,里面没有方法（推荐）")]),t._v(" "),v("li",[t._v("Externalizable")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("注意事项和细节说明")])]),t._v(" "),v("ol",[v("li",[t._v("读写顺序要一致")]),t._v(" "),v("li",[t._v("要求序列化或反序列化对象，需要实现 Serializable")]),t._v(" "),v("li",[t._v("序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性")]),t._v(" "),v("li",[t._v("序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员")]),t._v(" "),v("li",[t._v("序列化对象时，要求里面属性的类型也需要实现序列化接口")]),t._v(" "),v("li",[t._v("序列化具备可继承性")])]),t._v(" "),v("blockquote",[v("p",[t._v("标准输入输出流")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("--")]),t._v(" "),v("th",[t._v("类型")]),t._v(" "),v("th",[t._v("默认设备")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("System.in 标准输入")]),t._v(" "),v("td",[t._v("InputStream")]),t._v(" "),v("td",[t._v("键盘")])]),t._v(" "),v("tr",[v("td",[t._v("System.out 标准输出")]),t._v(" "),v("td",[t._v("PrintStream")]),t._v(" "),v("td",[t._v("显示器")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("转换流 InputStreamReader 和 OutputStreamWriter")])]),t._v(" "),v("ul",[v("li",[t._v("介绍")])]),t._v(" "),v("ol",[v("li",[t._v("InputStreamReader：Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）")]),t._v(" "),v("li",[t._v("OutputStreamWriter：Writer的子类，实现将OutputStream（字节流）包装成Writer（字符流）")]),t._v(" "),v("li",[t._v("当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议\n将字节流转换成字符流")]),t._v(" "),v("li",[t._v("可以在使用时指定编码格式（比如 utf-8，gbk，gb2312，ISO8859-1等）")])]),t._v(" "),v("h2",{attrs:{id:"网络相关概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络相关概念"}},[t._v("#")]),t._v(" 网络相关概念")]),t._v(" "),v("ul",[v("li",[t._v("ip地址")]),t._v(" "),v("li",[t._v("域名和端口")]),t._v(" "),v("li",[t._v("网络协议")]),t._v(" "),v("li",[t._v("TCP和UDP")]),t._v(" "),v("li",[t._v("InetAddress类")])]),t._v(" "),v("blockquote",[v("p",[t._v("相关方法")])]),t._v(" "),v("ol",[v("li",[t._v("获取本机InetAddress对象getLocalHost")]),t._v(" "),v("li",[t._v("根据指定主机名/域名获取ip地址对象getByName")]),t._v(" "),v("li",[t._v("获取InetAddresst对象的主机名getHostName")]),t._v(" "),v("li",[t._v("获取InetAddress对象的地址getHostAddress")])]),t._v(" "),v("h1",{attrs:{id:"流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流"}},[t._v("#")]),t._v(" 流")]),t._v(" "),v("h1",{attrs:{id:"文件基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件基础知识"}},[t._v("#")]),t._v(" 文件基础知识")]),t._v(" "),v("blockquote",[v("p",[t._v("创建文件对象相关构造器和方法")])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("new File(String pathname)//根据路径构建一个File对象\nnew File(File parent,String child)//根据父目录文件+子路径构建\nnew File(String parent,String child)//根据父目录+子路径构建\n")])])]),v("h2",{attrs:{id:"io流原理及流的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#io流原理及流的分类"}},[t._v("#")]),t._v(" IO流原理及流的分类")]),t._v(" "),v("blockquote",[v("p",[t._v("流的分类")])]),t._v(" "),v("ul",[v("li",[t._v("按操作数据单位不同分类为：字节流（8bit）二进制文件，字符流（按字符）文本文件")]),t._v(" "),v("li",[t._v("按数据流的流向不同分为：输入流，输出流")]),t._v(" "),v("li",[t._v("按流的角色的不同分类：节点流，处理流/包装流")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("（抽象基类）")]),t._v(" "),v("th",[t._v("字节流")]),t._v(" "),v("th",[t._v("字符流")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("输入流")]),t._v(" "),v("td",[t._v("InputStream")]),t._v(" "),v("td",[t._v("Reader")])]),t._v(" "),v("tr",[v("td",[t._v("输出流")]),t._v(" "),v("td",[t._v("OutputStream")]),t._v(" "),v("td",[t._v("Writer")])])])]),t._v(" "),v("h2",{attrs:{id:"io流常用体系图-常用类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#io流常用体系图-常用类"}},[t._v("#")]),t._v(" IO流常用体系图-常用类")]),t._v(" "),v("p",[t._v("FileInputStream\nFileOutputStream")]),t._v(" "),v("blockquote",[v("p",[t._v("FileReader和FileWriter介绍")])]),t._v(" "),v("p",[t._v("FileReader和FileWriter是字符流，即按照字符来操作io")]),t._v(" "),v("blockquote",[v("p",[t._v("FileReader相关方法")])]),t._v(" "),v("ol",[v("li",[t._v("new FileReader（File/String）")]),t._v(" "),v("li",[t._v("read：每次读取单个字符，返回该字符，如果到文件末尾返回-1")]),t._v(" "),v("li",[t._v("read（char[]）：批量读取多个字符到数组，返回读取的字符数，如果到文件末尾返回-1\n相关 API:")]),t._v(" "),v("li",[t._v("new String（char[]):将char[]转换成String")]),t._v(" "),v("li",[t._v("new String（char[],off,len):将char[]的指定部分转换成String")])]),t._v(" "),v("blockquote",[v("p",[t._v("FileWriter相关方法")])]),t._v(" "),v("ol",[v("li",[t._v("new FileWriter（File/String）:覆盖模式，相当于流的指针在首端")]),t._v(" "),v("li",[t._v("new FileWriter（File/String,true）:追加模式，相当于流的指针在尾端")]),t._v(" "),v("li",[t._v("writer(int)：写入单个字符")]),t._v(" "),v("li",[t._v("writer(char[])：写入指定数组")]),t._v(" "),v("li",[t._v("writer(char[],off,len)；写入数组的指定部分")]),t._v(" "),v("li",[t._v("writer(string)；写入整个字符串")]),t._v(" "),v("li",[t._v("writer(string,off,len)；写入字符串的指定部分\n相关 API:String类： toCharArray：将String转换成char[]")])]),t._v(" "),v("blockquote",[v("p",[t._v("注意\nFileWriter使用后，必须关闭(close)或刷新(flush)，否则写入不到指定的文件")])]),t._v(" "),v("h2",{attrs:{id:"节点流和处理流-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#节点流和处理流-2"}},[t._v("#")]),t._v(" 节点流和处理流")]),t._v(" "),v("blockquote",[v("p",[t._v("基本介绍")])]),t._v(" "),v("ol",[v("li",[t._v("节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter")]),t._v(" "),v("li",[t._v("处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter")])]),t._v(" "),v("h2",{attrs:{id:"节点和处理流的区别和联系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#节点和处理流的区别和联系"}},[t._v("#")]),t._v(" 节点和处理流的区别和联系")]),t._v(" "),v("ol",[v("li",[t._v("节点流是底层流/低级流，直接跟数据源相接")]),t._v(" "),v("li",[t._v("处理流（包装流）包装节点流，即可消除不同节点流的实现差异，也可以提供更\n方便的方法来完成输入输出")]),t._v(" "),v("li",[t._v("处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连")])]),t._v(" "),v("p",[t._v("处理流的功能主要体现在以下两个方面：")]),t._v(" "),v("ol",[v("li",[t._v("性能的提高：主要以增加缓冲的方式来提高输入输出的效率")]),t._v(" "),v("li",[t._v("操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便")])]),t._v(" "),v("h2",{attrs:{id:"打印流-printstream和printwriter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#打印流-printstream和printwriter"}},[t._v("#")]),t._v(" 打印流-PrintStream和PrintWriter")]),t._v(" "),v("h2",{attrs:{id:"properties类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#properties类"}},[t._v("#")]),t._v(" Properties类")]),t._v(" "),v("p",[t._v("基本介绍")]),t._v(" "),v("ol",[v("li",[t._v("专门用于读写配置文件的集合类\n配置文件的格式：\n键=值\n键=值")]),t._v(" "),v("li",[t._v("注意：键值对不需要有空格，之不需要用引号引起来，默认类型是String")])]),t._v(" "),v("h1",{attrs:{id:"反射"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[t._v("#")]),t._v(" 反射")]),t._v(" "),v("h2",{attrs:{id:"java反射机制可以完成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java反射机制可以完成"}},[t._v("#")]),t._v(" java反射机制可以完成")]),t._v(" "),v("p",[t._v("1.在运行时判断任意一个对象所属的类\n2.在运行时构造任意一个类的对象\n3.在运行时得到任意一个类所具有的成员变量和方法\n4.在运行时调用任意一个对象的成员变量和方法\n5.生成动态代理")]),t._v(" "),v("h2",{attrs:{id:"反射主要的类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反射主要的类"}},[t._v("#")]),t._v(" 反射主要的类")]),t._v(" "),v("p",[t._v("1.java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象\n2.java.lang.reflect.Method：代表类的方法，Method对象表示某个类的方法\n3.java.lang.reflect.Field:代表类的成员变量，Field对象表示某个类的成员变量\n4.java.lang.reflect.Constructor:代表类的构造方法，Constructor对象表示构造器")]),t._v(" "),v("h2",{attrs:{id:"反射的优点和缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反射的优点和缺点"}},[t._v("#")]),t._v(" 反射的优点和缺点")]),t._v(" "),v("ol",[v("li",[t._v("优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有\n反射机制，框架技术就失去底层支撑。")]),t._v(" "),v("li",[t._v("缺点：使用反射基本是解释执行，对执行速度有影响")])]),t._v(" "),v("h2",{attrs:{id:"反射调用优化-关闭访问检查"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反射调用优化-关闭访问检查"}},[t._v("#")]),t._v(" 反射调用优化-关闭访问检查")]),t._v(" "),v("ol",[v("li",[t._v("Method和Filed、Constructor对象都拥有setAccessible()方法")]),t._v(" "),v("li",[t._v("setAccessible作用是启动和禁用访问安全检查的开关")]),t._v(" "),v("li",[t._v("参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率，参数值\n为false则表示反射的对象执行访问检查")])]),t._v(" "),v("h2",{attrs:{id:"class类分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class类分析"}},[t._v("#")]),t._v(" Class类分析")]),t._v(" "),v("ol",[v("li",[t._v("Class也是类，因此也继承Object类")]),t._v(" "),v("li",[t._v("Class类对象不是new出来的，而是系统创建的")]),t._v(" "),v("li",[t._v("对于某个类的Class类对象，在内存中只有一份，因为类只加载一次")]),t._v(" "),v("li",[t._v("每个类的实例都会记得自己是由那个Class实例所生成")]),t._v(" "),v("li",[t._v("通过Class可以完整地得到一个类的完整结构，通过一系列API")]),t._v(" "),v("li",[t._v("Class对象存放在堆")]),t._v(" "),v("li",[t._v("类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等）")])]),t._v(" "),v("h2",{attrs:{id:"java反射机制原理示意图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java反射机制原理示意图"}},[t._v("#")]),t._v(" Java反射机制原理示意图")]),t._v(" "),v("h2",{attrs:{id:"class类常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class类常用方法"}},[t._v("#")]),t._v(" Class类常用方法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法名")]),t._v(" "),v("th",[t._v("功能说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("staic Class forName(String name)")]),t._v(" "),v("td",[t._v("放回指定类名name的Class对象")])]),t._v(" "),v("tr",[v("td",[t._v("Object newInstance()")]),t._v(" "),v("td",[t._v("调用缺省构造函数，返回该Class对象的一个实例")])]),t._v(" "),v("tr",[v("td",[t._v("getName()")]),t._v(" "),v("td",[t._v("返回此Class对象所表示的实体(类、接口、数组类、基本类型等）名称")])]),t._v(" "),v("tr",[v("td",[t._v("Class[] getInterfaces()")]),t._v(" "),v("td",[t._v("获取当前Class对象的接口")])]),t._v(" "),v("tr",[v("td",[t._v("ClassLoader getClassLoader()")]),t._v(" "),v("td",[t._v("返回该类的类加载器")])]),t._v(" "),v("tr",[v("td",[t._v("Class getSuperclass()")]),t._v(" "),v("td",[t._v("返回表示此Class所表示的实体的超类的Class")])]),t._v(" "),v("tr",[v("td",[t._v("Constructor[] getConstructors()")]),t._v(" "),v("td",[t._v("返回一个包含某些Constructor对象的数组")])]),t._v(" "),v("tr",[v("td",[t._v("Field[] getDeclaredFields()")]),t._v(" "),v("td",[t._v("返回Field对象的一个数组")])]),t._v(" "),v("tr",[v("td",[t._v("Method getMethod（String name,Class ... paramTypes)")]),t._v(" "),v("td",[t._v("返回一个Method对象，此对象的形参类型为paramType")])])])]),t._v(" "),v("h2",{attrs:{id:"获取class类对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#获取class类对象"}},[t._v("#")]),t._v(" 获取Class类对象")]),t._v(" "),v("ol",[v("li",[v("p",[t._v('前提：已知一个类的全类名，且该类在类路锦下，可通过Class类的静态方法forName（）获取\n实例：Class cls1 = Class.forName(""java.lang.Cat");\n应用场景：多用于配置文件，读取类全路径，加载类')])]),t._v(" "),v("li",[v("p",[t._v("前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能\n最高实例：Class cls2 = Cat.class；\n应用场景：多用于参数传递，比如通过反射得到对应构造器对象")])]),t._v(" "),v("li",[v("p",[t._v("前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象，实例：\nClass clazz = 对象.getClass();\n应用场景：通过创建好的对象，获取Class对象")])]),t._v(" "),v("li",[v("p",[t._v('其他方式(类加载器)\nClassLoader cl = 对象.getClass().getClassLoader();\nClass clazz4 = cl.loadClass("类的全类名");')])]),t._v(" "),v("li",[v("p",[t._v("基本数据按如下方式得到Class类对象\nClass cls = 基本数据类型.class")])]),t._v(" "),v("li",[v("p",[t._v("基本数据类型对应的包装类，可以通过.type得到Class类对象\nClass cls = 包装类.TYPE")])])]),t._v(" "),v("h2",{attrs:{id:"如下类型有class对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如下类型有class对象"}},[t._v("#")]),t._v(" 如下类型有Class对象")]),t._v(" "),v("ol",[v("li",[t._v("外部类，成员内部类，静态内部类，局部内部类。匿名内部类")]),t._v(" "),v("li",[t._v("interface：接口")]),t._v(" "),v("li",[t._v("数组")]),t._v(" "),v("li",[t._v("enum：枚举")]),t._v(" "),v("li",[t._v("annotation：注解")]),t._v(" "),v("li",[t._v("基本数据类型")]),t._v(" "),v("li",[t._v("void")])]),t._v(" "),v("h1",{attrs:{id:"类加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载"}},[t._v("#")]),t._v(" 类加载")]),t._v(" "),v("h2",{attrs:{id:"基本说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本说明"}},[t._v("#")]),t._v(" 基本说明")]),t._v(" "),v("p",[t._v("反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载")]),t._v(" "),v("ol",[v("li",[t._v("静态加载：编译时加载相关的类，如果没有则报错，依赖性太强")]),t._v(" "),v("li",[t._v("动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性")])]),t._v(" "),v("h2",{attrs:{id:"类加载时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载时机"}},[t._v("#")]),t._v(" 类加载时机")]),t._v(" "),v("ol",[v("li",[t._v("当创建对象时（new） //静态加载")]),t._v(" "),v("li",[t._v("当子类被加载时，父类也加载 //静态加载")]),t._v(" "),v("li",[t._v("调用类中的静态成员时 //静态加载")]),t._v(" "),v("li",[t._v("通过反射 //动态加载")])]),t._v(" "),v("h2",{attrs:{id:"类加载的五个阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载的五个阶段"}},[t._v("#")]),t._v(" 类加载的五个阶段")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("加载阶段")]),t._v(" "),v("p",[t._v("JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是\njar包、甚至网络）转换为二进制字节流加载到内存，并生成一个代表类的java.lang.Class对象")])]),t._v(" "),v("li",[v("p",[t._v("连接阶段-验证")])])]),t._v(" "),v("ol",[v("li",[t._v("目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会\n危害虚拟机自身的安全")]),t._v(" "),v("li",[t._v("包括：文件格式验证（是否以魔数 ox cafebabe开头）、元数据验证、字节码验证和符号引用验证")]),t._v(" "),v("li",[t._v("可以考虑使用 -Xverify:none参数来关闭大部分的类验证设施，缩短虚拟机类加载的时间")])]),t._v(" "),v("ul",[v("li",[t._v("连接阶段——准备")])]),t._v(" "),v("ol",[v("li",[t._v("JVM会在该阶段对静态变量，分配内存并初始化（对应数据类型的默认初始值\n如0、0L、null、false等）。这些变量所使用的内存都将在方法区中进行分配")])]),t._v(" "),v("ul",[v("li",[t._v("连接阶段——解析")])]),t._v(" "),v("ol",[v("li",[t._v("虚拟机将常量池内的符号引用替换为直接引用的过程")])]),t._v(" "),v("ul",[v("li",[t._v("Initialization(初始化)")])]),t._v(" "),v("ol",[v("li",[t._v("到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行"),v("clinit",[t._v("()方法的过程")])],1),t._v(" "),v("li",[v("clinit",[t._v("()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有\n静态变量的赋值动作和静态代码块中的语句，并进行合并")])],1),t._v(" "),v("li",[t._v("虚拟机会保证一个类的"),v("clinit",[t._v("()方法在多线程环境中被正确地加锁、同步，如果多个线程同时取初始化一个类\n，那么只会有一个线程取执行这个类的"),v("clinit",[t._v("()方法，其他线程都需要阻塞等待，直到活动线程执行"),v("clinit",[t._v("()方法完毕")])],1)],1)],1)]),t._v(" "),v("h2",{attrs:{id:"通过反射获取类的结构信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过反射获取类的结构信息"}},[t._v("#")]),t._v(" 通过反射获取类的结构信息")]),t._v(" "),v("h2",{attrs:{id:"通过反射创建对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过反射创建对象"}},[t._v("#")]),t._v(" 通过反射创建对象")]),t._v(" "),v("ol",[v("li",[t._v("方式一：调用类中的public修饰的无参构造器")]),t._v(" "),v("li",[t._v("方式二：调用类中的指定构造器")]),t._v(" "),v("li",[t._v("Class类相关方法")])]),t._v(" "),v("ul",[v("li",[t._v("newInstance：调用类中的无参构造器，获取对应类的对象")]),t._v(" "),v("li",[t._v("getConstructor(Class..clazz):根据参数列表，获取对应的public构造器对象")]),t._v(" "),v("li",[t._v("getDeclaredConstructor(Class..clazz)根据参数列表，获取对应的所有构造器对象")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("Constructor类相关方法")])]),t._v(" "),v("ul",[v("li",[t._v("setAccessible:爆破")]),t._v(" "),v("li",[t._v("newInstance(Object...obj):调用构造器")])]),t._v(" "),v("h2",{attrs:{id:"通过反射访问类中的属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过反射访问类中的属性"}},[t._v("#")]),t._v(" 通过反射访问类中的属性")]),t._v(" "),v("ol",[v("li",[t._v("根据属性名获取Field对象\nField f = clazz对象.getDeclaredField(属性名);")]),t._v(" "),v("li",[t._v("爆破：f.setAccessible(true); f是Field")]),t._v(" "),v("li",[t._v("访问\nf.set(o,值);//o表示对象")]),t._v(" "),v("li",[t._v("注意：如果是静态属性，则set和get中的参数0，可以写成null")])]),t._v(" "),v("h2",{attrs:{id:"通过反射访问类中的成员"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过反射访问类中的成员"}},[t._v("#")]),t._v(" 通过反射访问类中的成员")]),t._v(" "),v("ol",[v("li",[t._v("根据方法名和参数列表后去Method方法对象：\nMethod m = clazz.getDeclaredMethod(方法名，XX。class);//得到本类的所有方法")]),t._v(" "),v("li",[t._v("获取对象：Object 0 = clazz.newInstance();")]),t._v(" "),v("li",[t._v("爆破：m.setAccessible(true);")]),t._v(" "),v("li",[t._v("访问：Object returnValue = m.invoke(o,实参列表);//o就是对象")]),t._v(" "),v("li",[t._v("注意：如果是静态方法，则invoke的参数o，可以写成null")])]),t._v(" "),v("h1",{attrs:{id:"java8新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java8新特性"}},[t._v("#")]),t._v(" java8新特性")]),t._v(" "),v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),v("ul",[v("li",[t._v("速度更快")]),t._v(" "),v("li",[t._v("代码更少（增加了新的语法：Lambda表达式）")]),t._v(" "),v("li",[t._v("强大的Stream API")]),t._v(" "),v("li",[t._v("便于并行")]),t._v(" "),v("li",[t._v("最大化减少空指针异常：Optional")]),t._v(" "),v("li",[t._v("Nashorn引擎，允许在JVM上运行JS应用(jjs)")])]),t._v(" "),v("p",[t._v("并行流与串行流\n并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。\n相比较串行的流，并行的流可以很大程序上提高程序的执行效率")]),t._v(" "),v("p",[t._v("java8中将并行进行了优化，可以很容易的对数据进行并行操作。StreamAPI可以声明性\n地通过paralle()与sequential()在并行流与顺序流之间进行切换")]),t._v(" "),v("ol",[v("li",[t._v("Lambda表达式")]),t._v(" "),v("li",[t._v("函数式接口")]),t._v(" "),v("li",[t._v("方法引用与构造器引用")]),t._v(" "),v("li",[t._v("强大的StreamAPI")]),t._v(" "),v("li",[t._v("Optional类")])]),t._v(" "),v("h2",{attrs:{id:"lambda表达式语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式语法"}},[t._v("#")]),t._v(" Lambda表达式语法")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("举例：(o1，o2) -> Integer.compare(o1,o2);")])]),t._v(" "),v("li",[v("p",[t._v("格式：\n-> :lambda操作符或箭头操作符\n-> 左边：lambda形参列表（其实就是接口中的抽象方法的形参列表）\n-> 右边：lambda体（其实就是重写的抽象方法的方法体）")])]),t._v(" "),v("li",[v("p",[t._v("表达式的使用：\n总结\n左边：lambda形参列表的参数类型可以省略（类型推断）；如果lambda形参列表只有一个参数，其一对（）也可以省略\n右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字")])]),t._v(" "),v("li",[v("p",[t._v("lambda表达式的本质：作为接口的实列")])]),t._v(" "),v("li",[v("p",[t._v("如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用@Functionallnterface注解，这样可以\n检查它是否一个函数式接口")])]),t._v(" "),v("li",[v("p",[t._v("用匿名实现类表示的现在都可以用Lambda表达式替换")])])]),t._v(" "),v("h2",{attrs:{id:"java操作mysql数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java操作mysql数据库"}},[t._v("#")]),t._v(" java操作mysql数据库")]),t._v(" "),v("blockquote",[v("p",[t._v("java内置的4大核心函数式接口")])]),t._v(" "),v("ul",[v("li",[t._v("消费型接口 Consumer"),v("T",[t._v("    void accept(T t)")])],1),t._v(" "),v("li",[t._v("供给型接口 Supplier"),v("T",[t._v("    T get()")])],1),t._v(" "),v("li",[t._v("函数型接口 Function<T,R>  R apply(T,t)")]),t._v(" "),v("li",[t._v("断定型接口 Predicate"),v("T",[t._v("   boolean test(T t)")])],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);